<!DOCTYPE html>
<html lang="en" class="template-editor">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTRPG Template Editor</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script src="data.js"></script>
  <script src="utils.js"></script>
</head>

<body x-data="templateEditor()">

<div class="character-editor-container" :class="{ 'left-collapsed': leftPaneCollapsed, 'right-collapsed': rightPaneCollapsed, 'both-collapsed': leftPaneCollapsed && rightPaneCollapsed }">

    <!-- Unified Toolbar -->
    <div class="toolbar">
        <button class="toolbar-toggle" @click="toggleLeftPane" :class="{ 'active': !leftPaneCollapsed }">
            <span x-text="leftPaneCollapsed ? '‚ñ∂' : '‚óÄ'"></span>
            <span class="text-sm">Palette</span>
        </button>
        
        <h1>üìù Template Editor</h1>
        
        <div class="toolbar-actions">
            <select x-model="selectedSchemaId" @change="selectSchema($event.target.value)" class="form-control">
                <option value="">Select System...</option>
                <template x-for="schema in Utils.SelectSorting.sortObjectEntries(schemas, 'schemas')">
                    <option :value="schema.id" x-text="schema.title"></option>
                </template>
            </select>
            <select x-model="selectedTemplateId" @change="selectTemplate($event.target.value)" class="form-control" :disabled="!selectedSchemaId">
                <option value="">Select Template...</option>
                <option value="_new">+ Create New Template</option>
                <template x-for="template in Utils.SelectSorting.sortObjectEntries(availableTemplates, 'templates')">
                    <option :value="template.id" x-text="template.title"></option>
                </template>
            </select>
            <button class="btn btn-primary" @click="saveTemplate" :disabled="!currentTemplate || !isModified">üíæ Save</button>
        </div>
        
        <button class="toolbar-toggle" @click="toggleRightPane" :class="{ 'active': !rightPaneCollapsed }">
            <span class="text-sm">Properties</span>
            <span x-text="rightPaneCollapsed ? '‚óÄ' : '‚ñ∂'"></span>
        </button>
    </div>

    <!-- Left Pane - Element Palette -->
    <div class="left-pane" :class="{ 'collapsed': leftPaneCollapsed, 'show': leftPaneVisible }">
        <div class="pane-header">
            <h3 class="pane-title">üé® Element Palette</h3>
            <button class="pane-toggle" @click="toggleLeftPane">
                <span x-text="leftPaneCollapsed ? '‚ñ∂' : '‚óÄ'"></span>
            </button>
        </div>

    <div class="palette-content">
        <div class="element-section">
            <h4>Basic Elements</h4>
	    <div class="element-list" id="palette-basic">
                <template x-for="element in basicElements">
                    <div class="draggable-element">
                        <span class="element-icon" x-text="element.icon"></span>
                        <span class="element-name" x-text="element.name"></span>
                    </div>
                </template>
	    </div>
        </div>
        <div class="element-section">
            <h4>Layout Elements</h4>
	    <div class="element-list" id="palette-layout">
                <template x-for="element in layoutElements">
                    <div class="draggable-element">
                        <span class="element-icon" x-text="element.icon"></span>
                        <span class="element-name" x-text="element.name"></span>
                    </div>
                </template>
	    </div>
        </div>
        <div class="element-section">
            <h4>Advanced Elements</h4>
	    <div class="element-list" id="palette-advanced">
                <template x-for="element in advancedElements">
                    <div class="draggable-element">
                        <span class="element-icon" x-text="element.icon"></span>
                        <span class="element-name" x-text="element.name"></span>
                    </div>
                </template>
	    </div>
        </div>
    </div>

    <div class="pane-header">
        <h3 class="pane-title">üîß Tools</h3>
    </div>
    <div class="tools-content">
        <div class="tool-section">
            <h4 class="tool-section-title">üìÇ File Operations</h4>
            <button class="btn btn-primary btn-full-width btn-with-margin" @click="importTemplate" :disabled="!selectedSchemaId">
                üì§ Import
            </button>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="exportTemplate" :disabled="!selectedTemplateId || selectedTemplateId === '_new'">
                üì• Export
            </button>
            <div class="tool-note">
                <small>Import template files or export current template design.</small>
            </div>
        </div>

        <div class="tool-section">
            <h4 class="tool-section-title">üé® Template & Design</h4>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="previewTemplate" :disabled="!selectedTemplateId || selectedTemplateId === '_new'">
                üëÅÔ∏è Preview
            </button>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="editSchema" :disabled="!selectedSchemaId">
                üìã Edit Schema
            </button>
            <p class="tool-description">Preview templates and manage data schemas</p>
        </div>

        <div class="tool-section">
            <h4 class="tool-section-title">‚Ü∂ History</h4>
            <div class="undo-redo-controls">
                <button class="btn btn-secondary" @click="undo" :disabled="!canUndo" title="Undo last action (Ctrl+Z)">
                    ‚Ü∂ Undo (<span x-text="undoManager ? undoManager.undoStack.length : 0"></span>)
                </button>
                <button class="btn btn-secondary" @click="redo" :disabled="!canRedo" title="Redo last action (Ctrl+Y)">
                    ‚Ü∑ Redo (<span x-text="undoManager ? undoManager.redoStack.length : 0"></span>)
                </button>
            </div>
            <div class="tool-note">
                <small>Keyboard shortcuts: Ctrl+Z (undo), Ctrl+Y (redo)</small>
            </div>
        </div>
    </div>
</div>
    <!-- Main Canvas -->
    <div class="main-canvas">
        <template x-if="!currentTemplate">
            <div class="empty-state">
                <h2>Create a Template</h2>
                <p>Choose a schema and create a new template to get started</p>
                <div class="empty-state-actions">
                    <button class="btn btn-primary" @click="showCreateModal = true">‚ûï Create Template</button>
                </div>
            </div>
        </template>
        
        <template x-if="currentTemplate">
            <div class="canvas-content">
                <div class="template-header">
                    <input 
                        type="text" 
                        class="template-title-input" 
                        x-model="currentTemplate.title" 
                        placeholder="Template Title"
                        @input="markAsModified"
                    >
                    <span class="modified-indicator" x-show="isModified">‚óè Modified</span>
                </div>
                
                <div class="template-content">
                    <!-- Handle Tabs Layout -->
                    <template x-if="currentTemplate.type === 'Tabs'">
                        <div class="template-layout-indicator">
                            <div class="template-layout-header">
                                <h3 class="template-layout-title">Tab Layout</h3>
                                <button class="btn btn-secondary btn-small" @click="addTabToTemplate">‚ûï Add Tab</button>
                            </div>
                            <div class="tab-container">
                                <div class="tab-header" id="tab-header">
                                    <template x-for="(tab, index) in currentTemplate.elements">
                                        <button 
                                            class="tab-button" 
                                            :class="{ 'active': activeTemplateTab === index }" 
                                            @click="activeTemplateTab = index" 
                                            x-text="tab.label || ('Tab ' + (index + 1))"
                                            :data-tab-index="index">
                                        </button>
                                    </template>
                                </div>
                                <template x-for="(tab, index) in currentTemplate.elements">
                                    <div class="tab-content" :class="{ 'active': activeTemplateTab === index }">
                                        <div class="tab-drop-zone drop-zone" :data-tab-index="index" :id="'tab-content-' + index">
                                            <template x-if="!tab.elements || tab.elements.length === 0">
                                                <div class="drop-zone-placeholder">üéØ Drop elements here for this tab</div>
                                            </template>
                                            <template x-for="(element, elemIndex) in (tab.elements || [])">
						<div class="sortable-item" x-html="renderElement(element, elemIndex)" :data-element-id="element.id" data-sortable-handle></div>
                                            </template>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                        
                    <!-- Handle Non-Tabs Layout -->
                    <template x-if="currentTemplate.type !== 'Tabs'">
                        <div class="drop-zone main-drop-zone" id="main-canvas">
                            <template x-if="currentTemplate.elements.length === 0">
                                <div class="drop-zone-placeholder">üéØ Drop elements here to start building your template</div>
                            </template>
                            <template x-for="(element, index) in currentTemplate.elements">
                                <div class="sortable-item canvas-element" x-html="renderElement(element, index)" :data-element-id="element.id"></div>
                            </template>
                        </div>
                    </template>
                </div>
            </div>
        </template>
    </div>

    <!-- Right Pane - Properties Panel -->
    <div class="right-pane" :class="{ 'collapsed': rightPaneCollapsed, 'show': rightPaneVisible }">
        <div class="pane-header">
            <h3 class="pane-title">‚öôÔ∏è Properties</h3>
            <button class="pane-toggle" @click="toggleRightPane">
                <span x-text="rightPaneCollapsed ? '‚óÄ' : '‚ñ∂'"></span>
            </button>
        </div>
    
        <div class="properties-scroll">
            <template x-if="selectedElementId && currentTemplate">
		<div class="property-group appearance-group" x-data="{ generalOpen: true }">
		    <div class="property-group-header" @click="generalOpen = !generalOpen">
		        <h4 class="property-group-title collapsible-title">
		            <span class="collapse-icon" :class="{ 'collapsed': !generalOpen }" x-text="generalOpen ? '‚ñº' : '‚ñ∂'"></span>
		            General
		        </h4>
		    </div>
		    <div class="appearance-content" x-show="generalOpen">
		        <div class="form-group">
		            <label class="property-label">Element Type</label>
                            <input type="text" :value="getElementProperty('type')" class="form-control" readonly>
                        </div>

                        <div x-show="getElementProperty('type') === 'Control'">
                            <div class="form-group">
                                <label class="property-label">Control Type</label>
                                <select :value="getElementProperty('controlType')" @change="updateElementProperty('controlType', $event.target.value)" class="form-control">
                                    <option value="text">Text Input</option>
                                    <option value="number">Number Input</option>
				    <option value="date">Date Input</option>
                                    <option value="textarea">Textarea</option>
                                    <option value="select">Select</option>
                                    <option value="checkbox">Checkbox</option>
                                </select>
                            </div>
                        </div>

			<div x-show="['select'].includes(getElementProperty('controlType')) || getElementProperty('type') === 'SelectGroup'">
			    <div class="form-group">
				<label class="property-label">Options Source</label>
				<div class="formula-input-container">
				    <input 
					type="text" 
					:value="getElementProperty('optionsSource')" 
					@input="updateElementProperty('optionsSource', $event.target.value)"
					@keydown="handleOptionsKeydown($event)"
					@focus="showOptionsFieldSuggestions = true"
					@blur="setTimeout(() => showOptionsFieldSuggestions = false, 300)"
					class="form-control formula-input"
					placeholder='@field.path or ["Option 1", "Option 2"]'
					autocomplete="off">

				    <!-- Field suggestions dropdown (filtered for enums/arrays) -->
				    <div x-show="showOptionsFieldSuggestions && filteredEnumFields.length > 0" 
					class="field-suggestions" 
					x-transition:enter="transition ease-out duration-100"
					x-transition:enter-start="opacity-0 scale-95"
					x-transition:enter-end="opacity-100 scale-100"
					x-transition:leave="transition ease-in duration-75"
					x-transition:leave-start="opacity-100 scale-100"
					x-transition:leave-end="opacity-0 scale-95">
					<template x-for="field in filteredEnumFields.slice(0, 50)">
					    <div class="field-suggestion" @click="updateElementProperty('optionsSource', '@' + field.path); showOptionsFieldSuggestions = false" x-text="field.label + ' (' + field.path + ')'"></div>
					</template>
				    </div>
				</div>
				<div class="form-note">
				    <small>Field with enum/array values or static array like ["Red", "Blue", "Green"]</small>
				</div>
			    </div>
			</div>

                        <div x-show="elementNeedsScope(getElementProperty('type'))">
			    <div class="form-group">
				<label class="property-label">Scope</label>
				<div class="formula-input-container">
			            <input 
			            type="text" 
			            :value="getElementProperty('scope')" 
			            @input="updateElementProperty('scope', $event.target.value)"
			            @keydown="handleFormulaKeydown($event)"
			            @focus="showFieldSuggestions = true"
				    @blur="setTimeout(() => showFieldSuggestions = false, 300)"
			            class="form-control formula-input"
			            placeholder="@field.path or formula..."
			            autocomplete="off">
        
			            <!-- Field suggestions dropdown -->
			            <div x-show="showFieldSuggestions && filteredFields.length > 0" 
			             class="field-suggestions" 
			             x-transition:enter="transition ease-out duration-100"
			             x-transition:enter-start="opacity-0 scale-95"
			             x-transition:enter-end="opacity-100 scale-100"
			             x-transition:leave="transition ease-in duration-75"
			             x-transition:leave-start="opacity-100 scale-100"
			             x-transition:leave-end="opacity-0 scale-95">
			            <template x-for="field in filteredFields.slice(0, 50)">
			                <div class="field-suggestion" 
			                     @click="insertFieldReference(field.path)"
			                     x-text="field.label + ' (' + field.path + ')'">
			                </div>
			            </template>
			            </div>
			        </div>
    
			        <!-- Formula validation -->
			        <div x-show="getElementProperty('scope') && !isValidFormula(getElementProperty('scope'))" class="formula-error"> Invalid formula syntax </div>
    
			        <!-- Formula preview -->
			        <div x-show="getElementProperty('scope') && isFormula(getElementProperty('scope'))" class="formula-preview"> Formula: <code x-text="getElementProperty('scope')"></code> </div>
			    </div>
                        </div>

                        <div class="form-group">
                            <label class="property-label">Label</label>
                            <input type="text" :value="getElementProperty('label')" @input="updateElementProperty('label', $event.target.value)" class="form-control">
                        </div>
			<div x-show="getElementProperty('type') === 'Control' && getElementProperty('controlType') === 'textarea'">
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('richText') === true" @change="updateElementProperty('richText', $event.target.checked)">
			            <span>Rich Text (Markdown Editor)</span>
			        </label>
			    </div>
			</div>

                        <div x-show="getElementProperty('type') === 'Control'" class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" :checked="getElementProperty('readOnly') === true" @change="updateElementProperty('readOnly', $event.target.checked)">
                                <span>Read Only</span>
                            </label>
                        </div>

			<div x-show="getElementProperty('type') === 'Group'">
			    <div class="form-group">
			        <label class="property-label">Layout Type</label>
			        <select :value="getElementProperty('layout') || 'vertical'" @change="updateElementProperty('layout', $event.target.value)" class="form-control">
			            <option value="vertical">Vertical</option>
			            <option value="horizontal">Horizontal</option>
			            <option value="grid">Grid</option>
			            <option value="columns">Columns</option>
			            <option value="combo-row">Compact Row</option>
			            <option value="combo-compact">Compact Stack</option>
			        </select>
			    </div>
			    <div x-show="getElementProperty('layout') === 'columns'" class="form-group">
			        <label class="property-label">Number of Columns</label>
			        <select :value="getElementProperty('columns') || 2" @change="updateElementProperty('columns', parseInt($event.target.value))" class="form-control">
			            <option value="2">2 Columns</option>
			            <option value="3">3 Columns</option>
			            <option value="4">4 Columns</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Gap Size</label>
			        <select :value="getElementProperty('gap') || 'medium'" @change="updateElementProperty('gap', $event.target.value)" class="form-control">
			            <option value="none">None</option>
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Visual Style</label>
			        <select :value="getElementProperty('style') || 'plain'" @change="updateElementProperty('style', $event.target.value)" class="form-control">
			            <option value="plain">Plain</option>
			            <option value="fieldset">Fieldset (with border)</option>
			            <option value="card">Card</option>
			            <option value="subtle">Subtle Background</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('collapsible') === true" @change="updateElementProperty('collapsible', $event.target.checked)">
			            <span>Make Collapsible</span>
			        </label>
			    </div>
			    <div x-show="getElementProperty('collapsible') === true" class="form-group">
			        <label class="property-label">Default State</label>
			        <select :value="getElementProperty('defaultCollapsed') || 'open'" @change="updateElementProperty('defaultCollapsed', $event.target.value)" class="form-control">
			            <option value="open">Open</option>
			            <option value="collapsed">Collapsed</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Array'">
			    <div class="form-group">
			        <label class="property-label">Display Style</label>
			        <select :value="getElementProperty('displayStyle') || 'table'" @change="updateElementProperty('displayStyle', $event.target.value)" class="form-control">
			            <option value="table">Table</option>
			            <option value="cards">Cards</option>
			            <option value="compact">Compact List</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowAdd') !== false" @change="updateElementProperty('allowAdd', $event.target.checked)">
			            <span>Allow Adding Items</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowRemove') !== false" @change="updateElementProperty('allowRemove', $event.target.checked)">
			            <span>Allow Removing Items</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowReorder') !== false" @change="updateElementProperty('allowReorder', $event.target.checked)">
			            <span>Allow Drag & Drop Reordering</span>
			        </label>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'LinearTrack' || getElementProperty('type') === 'CircularTrack'">
                            <div class="form-group">
                                <label class="property-label">Field Path</label>
                                <select :value="getElementProperty('scope')" @change="updateElementProperty('scope', $event.target.value)" class="form-control">
                                    <option value="">Select a field...</option>
                                    <template x-for="field in availableFields">
                                        <option :value="field.path" x-text="field.label"></option>
                                    </template>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="property-label">Number of Segments</label>
                                <input type="number" :value="getElementProperty('segments') ? getElementProperty('segments') : 6" @input="updateElementProperty('segments', parseInt($event.target.value))" class="form-control" min="2" max="20">
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" :checked="getElementProperty('showCounter') !== false" @change="updateElementProperty('showCounter', $event.target.checked)">
                                    <span>Show Counter Text</span>
                                </label>
                            </div>
                        </div>

			<div x-show="getElementProperty('type') === 'MultiStateToggle'">
			    <div class="form-group">
			        <label class="property-label">Number of States</label>
			        <select :value="getElementProperty('states') || 2" @change="updateElementProperty('states', parseInt($event.target.value))" class="form-control">
			            <option value="2">2 States (Off/On)</option>
			            <option value="3">3 States (Off/On/Expert)</option>
			            <option value="4">4 States (Custom)</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Shape</label>
			        <select :value="getElementProperty('shape') || 'circle'" @change="updateElementProperty('shape', $event.target.value)" class="form-control">
			            <option value="circle">Circle</option>
			            <option value="square">Square</option>
			            <option value="diamond">Diamond</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Size</label>
			        <select :value="getElementProperty('size') || 'medium'" @change="updateElementProperty('size', $event.target.value)" class="form-control">
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Label Position</label>
			        <select :value="getElementProperty('labelPosition') || 'right'" @change="updateElementProperty('labelPosition', $event.target.value)" class="form-control">
			            <option value="left">Left</option>
			            <option value="right">Right</option>
			            <option value="above">Above</option>
			            <option value="below">Below</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'SelectGroup'">
			    <div class="form-group">
			        <label class="property-label">Selection Type</label>
			        <select :value="getElementProperty('selectionType') || 'multi'" @change="updateElementProperty('selectionType', $event.target.value)" class="form-control">
			            <option value="single">Single Select</option>
			            <option value="multi">Multi Select</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Display Mode</label>
			        <select :value="getElementProperty('displayMode') || 'all'" @change="updateElementProperty('displayMode', $event.target.value)" class="form-control">
			            <option value="all">Show All Options</option>
			            <option value="selected-only">Show Selected Only</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Visual Style</label>
			        <select :value="getElementProperty('style') || 'pills'" @change="updateElementProperty('style', $event.target.value)" class="form-control">
			            <option value="pills">Pills</option>
			            <option value="tags">Tags</option>
			            <option value="buttons">Buttons</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Image'">
			    <div class="form-group">
			        <label class="property-label">Data Field (Optional)</label>
			        <select :value="getElementProperty('scope')" @change="updateElementProperty('scope', $event.target.value)" class="form-control">
			            <option value="">Static Image (URL only)</option>
			            <template x-for="field in availableFields">
			                <option :value="field.path" x-text="field.label"></option>
			            </template>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Image Source (Static)</label>
			        <input type="text" :value="getElementProperty('src')" @input="updateElementProperty('src', $event.target.value)" class="form-control" placeholder="Enter image URL">
			    </div>
			    <div class="form-group">
			        <label class="property-label">Alt Text</label>
			        <input type="text" :value="getElementProperty('alt')" @input="updateElementProperty('alt', $event.target.value)" class="form-control" placeholder="Descriptive text">
			    </div>
			    <div class="form-group">
			        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
			            <div>
			                <label class="property-label">Width (px)</label>
					<input type="number" :value="getElementProperty('width') || 150" @input="updateImageDimension('width', parseInt($event.target.value))" class="form-control" min="20" max="800">
			            </div>
			            <div>
			                <label class="property-label">Height (px)</label>
					<input type="number" :value="getElementProperty('height') || 150" @input="updateImageDimension('height', parseInt($event.target.value))" class="form-control" min="20" max="800">
			            </div>
			        </div>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Shape</label>
			        <select :value="getElementProperty('shape') || 'square'" @change="updateElementProperty('shape', $event.target.value)" class="form-control">
			            <option value="square">Square</option>
			            <option value="circle">Circle</option>
			            <option value="rounded">Rounded</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Border Style</label>
			        <select :value="getElementProperty('borderStyle') || 'thin'" @change="updateElementProperty('borderStyle', $event.target.value)" class="form-control">
			            <option value="none">No Border</option>
			            <option value="thin">Thin Border</option>
			            <option value="thick">Thick Border</option>
			            <option value="accent">Accent Border</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowUpload') === true" @change="updateElementProperty('allowUpload', $event.target.checked)">
			            <span>Allow Upload in Character Sheet</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('maintainAspectRatio') === true" @change="updateElementProperty('maintainAspectRatio', $event.target.checked)">
			            <span>Maintain Aspect Ratio</span>
			        </label>
			    </div>
			</div>

                        <div x-show="getElementProperty('type') === 'Tab'">
                            <div class="form-group">
                                <label class="property-label">Tab Label</label>
                                <input type="text" :value="getElementProperty('label')" @input="updateElementProperty('label', $event.target.value)" class="form-control">
                            </div>
                        </div>
                    </div>

<div class="property-group appearance-group" x-data="{ appearanceOpen: false }" x-init="$watch('selectedElementId', () => { appearanceOpen = hasAnyColorSet(); })">
    <div class="property-group-header" @click="appearanceOpen = !appearanceOpen">
        <h4 class="property-group-title collapsible-title">
            <span class="collapse-icon" :class="{ 'collapsed': !appearanceOpen }" x-text="appearanceOpen ? '‚ñº' : '‚ñ∂'"></span>
            Appearance
        </h4>
    </div>
    
    <div class="appearance-content" x-show="appearanceOpen">
        <div x-show="elementSupportsTextSize()" class="form-group">
            <label class="property-label">Text Size</label>
            <select :value="getElementProperty('textSize') || 'medium'" @change="updateElementProperty('textSize', $event.target.value)" class="form-control">
                <option value="small">Small</option>
                <option value="medium">Medium (Default)</option>
                <option value="large">Large</option>
                <option value="xlarge">Extra Large</option>
            </select>
        </div>
        <div x-show="elementSupportsTextSize()" class="form-group">
            <label class="property-label">Text Style</label>
            <div class="button-toggle-group">
                <button type="button" 
                        class="button-toggle" 
                        :class="{ 'active': getElementProperty('textBold') === true }"
                        @click="updateElementProperty('textBold', !getElementProperty('textBold'))"
                        title="Bold">
                    <strong>B</strong>
                </button>
                <button type="button" 
                        class="button-toggle" 
                        :class="{ 'active': getElementProperty('textItalic') === true }"
                        @click="updateElementProperty('textItalic', !getElementProperty('textItalic'))"
                        title="Italic">
                    <em>I</em>
                </button>
                <button type="button" 
                        class="button-toggle" 
                        :class="{ 'active': getElementProperty('textUnderline') === true }"
                        @click="updateElementProperty('textUnderline', !getElementProperty('textUnderline'))"
                        title="Underline">
                    <u>U</u>
                </button>
            </div>
        </div>
        <div class="color-property-group">
            <div class="color-property-header" x-show="elementSupportsBackgroundColor()">
                <label class="property-label">Background Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('backgroundColor') || '#ffffff'}`"></div>
                    <span class="color-value" x-text="getElementProperty('backgroundColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in colorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('backgroundColor') === color.value }"
                         @click="updateElementProperty('backgroundColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('backgroundColor') || '#ffffff'" 
                           @input="updateElementProperty('backgroundColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('backgroundColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>

        <div x-show="elementSupportsBorderColor()" class="color-property-group">
            <div class="color-property-header">
                <label class="property-label">Border Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('borderColor') || '#e5e7eb'}`"></div>
                    <span class="color-value" x-text="getElementProperty('borderColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in colorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('borderColor') === color.value }"
                         @click="updateElementProperty('borderColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('borderColor') || '#e5e7eb'" 
                           @input="updateElementProperty('borderColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('borderColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>

        <div x-show="elementSupportsTextColor()" class="color-property-group">
            <div class="color-property-header">
                <label class="property-label">Text Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('textColor') || '#374151'}`"></div>
                    <span class="color-value" x-text="getElementProperty('textColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in textColorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('textColor') === color.value }"
                         @click="updateElementProperty('textColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('textColor') || '#374151'" 
                           @input="updateElementProperty('textColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('textColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>
    </div>
</div>

<div class="property-group appearance-group" x-data="{ alignmentOpen: false }" x-init="$watch('selectedElementId', () => { alignmentOpen = hasAnyAlignmentSet(); })" x-show="elementSupportsAlignment()">
    <div class="property-group-header" @click="alignmentOpen = !alignmentOpen">
        <h4 class="property-group-title collapsible-title">
            <span class="collapse-icon" :class="{ 'collapsed': !alignmentOpen }" x-text="alignmentOpen ? '‚ñº' : '‚ñ∂'"></span>
            Alignment & Layout
        </h4>
    </div>
    
    <div class="appearance-content" x-show="alignmentOpen">
        <div class="form-group">
            <label class="property-label">Label Alignment</label>
            <select :value="getElementProperty('labelAlignment') || 'left'" @change="updateElementProperty('labelAlignment', $event.target.value)" class="form-control">
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
            </select>
        </div>

        <div x-show="getElementProperty('type') === 'Group'" class="form-group">
            <label class="property-label">Content Alignment</label>
            <select :value="getElementProperty('contentAlignment') || 'left'" @change="updateElementProperty('contentAlignment', $event.target.value)" class="form-control">
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
            </select>
        </div>

        <div x-show="getElementProperty('type') === 'Control'" class="form-group">
            <label class="property-label">Layout Style</label>
            <select :value="getElementProperty('layout') || 'vertical'" @change="updateElementProperty('layout', $event.target.value)" class="form-control">
                <option value="vertical">Vertical (Label Above)</option>
                <option value="horizontal">Horizontal (Side by Side)</option>
                <option value="compact">Compact (Centered)</option>
            </select>
        </div>

        <div x-show="getElementProperty('type') === 'Control' && getElementProperty('layout') === 'horizontal'" class="form-group">
            <label class="property-label">Label Position</label>
            <select :value="getElementProperty('labelPosition') || 'left'" @change="updateElementProperty('labelPosition', $event.target.value)" class="form-control">
                <option value="left">Left of Input</option>
                <option value="right">Right of Input</option>
                <option value="above">Above Input</option>
                <option value="below">Below Input</option>
            </select>
        </div>

        <div x-show="getElementProperty('type') === 'Control' && !['checkbox'].includes(getElementProperty('controlType'))" class="form-group">
            <label class="property-label">Text Alignment</label>
            <select :value="getElementProperty('textAlignment') || 'left'" @change="updateElementProperty('textAlignment', $event.target.value)" class="form-control">
                <option value="left">Left</option>
                <option value="center">Center</option>
                <option value="right">Right</option>
            </select>
        </div>

        <div x-show="getElementProperty('type') === 'Control'" class="form-group">
            <label class="property-label">Input Width</label>
            <select :value="getElementProperty('width') || 'auto'" @change="updateElementProperty('width', $event.target.value)" class="form-control">
                <option value="">Auto (Full Width)</option>
                <option value="80">Small (80px)</option>
                <option value="120">Medium (120px)</option>
                <option value="200">Large (200px)</option>
                <option value="0">Custom...</option>
            </select>
        </div>

        <div x-show="getElementProperty('width') === 'custom'" class="form-group">
            <label class="property-label">Custom Width (px)</label>
            <input type="number" 
                   :value="getElementProperty('customWidth') || 150" 
                   @input="updateElementProperty('customWidth', $event.target.value); updateElementProperty('width', $event.target.value + 'px')" 
                   class="form-control" 
                   min="50" 
                   max="500"
                   placeholder="150">
        </div>

        <div x-show="getElementProperty('type') === 'Control'" class="form-group">
            <label class="property-label">Quick Presets</label>
            <div class="alignment-presets">
                <button type="button" class="btn btn-secondary btn-small" @click="applyAlignmentPreset('combo')">
                    üìä Combo Style
                </button>
                <button type="button" class="btn btn-secondary btn-small" @click="applyAlignmentPreset('centered')">
                    ‚¨áÔ∏è Centered
                </button>
                <button type="button" class="btn btn-secondary btn-small" @click="applyAlignmentPreset('compact')">
                    üì± Compact
                </button>
                <button type="button" class="btn btn-secondary btn-small" @click="applyAlignmentPreset('default')">
                    üîÑ Default
                </button>
            </div>
        </div>
    </div>
</div>

                    <div class="property-group">
                        <h4 class="property-group-title">Actions</h4>
                        <button class="btn btn-secondary btn-full-width btn-with-margin" @click="duplicateElement(selectedElementId)">üìã Duplicate</button>
                        <button class="btn btn-danger btn-full-width" @click="deleteElement(selectedElementId)">üóëÔ∏è Delete</button>
                    </div>
                </div>
            </template>
            <template x-if="!selectedElementId">
                <div class="empty-state-small">Select an element to edit its properties</div>
            </template>
        </div>
    </div>

<!-- Create Template Modal -->
<template x-if="showCreateModal">
    <div class="modal-overlay" @click.self="showCreateModal = false">
        <div class="modal">
            <div class="modal-header">
                <h3>Create New Template</h3>
                <button class="modal-close" @click="showCreateModal = false">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Template Title</label>
                    <input type="text" x-model="newTemplate.title" class="form-control" placeholder="Enter template title">
                </div>
                <div class="form-group">
                    <label>Schema</label>
                    <select x-model="newTemplate.schema" class="form-control">
                        <option value="">Select Schema...</option>
                        <template x-for="schema in Object.values(schemas)">
                            <option :value="schema.index" x-text="schema.title"></option>
                        </template>
                    </select>
                </div>
                <div class="form-group">
                    <label>Layout Type</label>
                    <select x-model="newTemplate.type" class="form-control">
                        <option value="VerticalLayout">Vertical Layout</option>
                        <option value="Tabs">Tabs Layout</option>
                    </select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" @click="showCreateModal = false">Cancel</button>
                <button class="btn btn-primary" @click="createTemplate" :disabled="!newTemplate.title || !newTemplate.schema">Create Template</button>
            </div>
        </div>
    </div>
</template>

<script>
function templateEditor() {
    return {
        Utils: Utils,
        schemas: {},
        currentTemplate: null,
        selectedElementId: null,
        selectedSchemaId: '',
        selectedTemplateId: '',
        availableTemplates: {},
        availableFields: [],
        showCreateModal: false,
        isModified: false,
        activeTemplateTab: 0,
        leftPaneCollapsed: false,
        rightPaneCollapsed: false,
        leftPaneVisible: true,
        rightPaneVisible: true,
        newTemplate: { title: '', schema: '', type: 'VerticalLayout' },
        undoManager: null,
        canUndo: false,
        canRedo: false,
	showFieldSuggestions: false,
	showOptionsFieldSuggestions: false,
	isDragMode: false,
        sortables: {},
        
	basicElements: [
	    { type: 'Control', name: 'Text Input', icon: 'üìù', controlType: 'text' },
	    { type: 'Control', name: 'Number Input', icon: 'üî¢', controlType: 'number' },
	    { type: 'Control', name: 'Date Input', icon: 'üìÖ', controlType: 'date' },
	    { type: 'Control', name: 'Textarea', icon: 'üìÑ', controlType: 'textarea' },
	    { type: 'Control', name: 'Select', icon: 'üìã', controlType: 'select' },
	    { type: 'Label', name: 'Label', icon: 'üìù' },
	    { type: 'Divider', name: 'Divider', icon: '‚ûñ' },
	],
	layoutElements: [
	    { type: 'Group', name: 'Group', icon: 'üì¶' },
	    { type: 'Tabs', name: 'Tabs', icon: 'üìë' },
	],
	advancedElements: [
	    { type: 'Array', name: 'Array/List', icon: 'üìö' },
	    { type: 'LinearTrack', name: 'Linear Track', icon: '‚ñ≠' },
	    { type: 'CircularTrack', name: 'Circular Clock', icon: 'üïê' },
	    { type: 'MultiStateToggle', name: 'Multi-State Toggle', icon: 'üéØ' },
	    { type: 'SelectGroup', name: 'Select Group', icon: 'üè∑Ô∏è' },
	    { type: 'Image', name: 'Image', icon: 'üñºÔ∏è' },
	],

	colorPresets: [
		    { name: 'White', value: '#ffffff' },
		    { name: 'Light Gray', value: '#f8fafc' },
		    { name: 'Blue', value: '#3b82f6' },
		    { name: 'Green', value: '#059669' },
		    { name: 'Red', value: '#dc2626' },
		    { name: 'Orange', value: '#d97706' },
		    { name: 'Purple', value: '#7c3aed' },
		    { name: 'Yellow', value: '#eab308' },
		    { name: 'Pink', value: '#ec4899' },
		    { name: 'Indigo', value: '#4f46e5' },
		    { name: 'Teal', value: '#0d9488' },
		    { name: 'Black', value: '#111827' }
	],

	textColorPresets: [
		    { name: 'Dark Gray', value: '#374151' },
		    { name: 'Black', value: '#111827' },
		    { name: 'Blue', value: '#3b82f6' },
		    { name: 'Green', value: '#059669' },
		    { name: 'Red', value: '#dc2626' },
		    { name: 'Orange', value: '#d97706' },
		    { name: 'Purple', value: '#7c3aed' },
		    { name: 'Yellow', value: '#eab308' },
		    { name: 'Pink', value: '#ec4899' },
		    { name: 'Indigo', value: '#4f46e5' },
		    { name: 'Teal', value: '#0d9488' },
		    { name: 'White', value: '#ffffff' }
	],

        init() {
            this.initializeData();
            this.setupUndoManager();
	    this.handleUrlParameters();
            this.$watch('selectedSchemaId', () => this.onSchemaChanged());
            this.$watch('selectedTemplateId', () => this.onTemplateChanged());
            
            this.$nextTick(() => {
                this.initSortables();
            });
        },

        initSortables() {
            // Initialize sortable for element palette
            const paletteBasic = document.getElementById('palette-basic');
            const paletteLayout = document.getElementById('palette-layout');
            const paletteAdvanced = document.getElementById('palette-advanced');
            
            if (paletteBasic) {
                Sortable.create(paletteBasic, {
                    group: { name: 'editor', pull: 'clone', put: false },
                    sort: false,
                    onStart: (evt) => {
                        const elementData = this.basicElements[evt.oldIndex];
                        evt.item.setAttribute('data-element', JSON.stringify(elementData));
                    }
                });
            }
            
            if (paletteLayout) {
                Sortable.create(paletteLayout, {
                    group: { name: 'editor', pull: 'clone', put: false },
                    sort: false,
                    onStart: (evt) => {
                        const elementData = this.layoutElements[evt.oldIndex];
                        evt.item.setAttribute('data-element', JSON.stringify(elementData));
                    }
                });
            }

            if (paletteAdvanced) {
                Sortable.create(paletteAdvanced, {
                    group: { name: 'editor', pull: 'clone', put: false },
                    sort: false,
                    onStart: (evt) => {
                        const elementData = this.advancedElements[evt.oldIndex];
                        evt.item.setAttribute('data-element', JSON.stringify(elementData));
                    }
                });
            }

            // Initialize tab sortable if tabs exist
            this.initTabSortable();
            
            // Initialize main canvas sortable
            this.initCanvasSortable();
        },

        initTabSortable() {
            const tabHeader = document.getElementById('tab-header');
            if (tabHeader && this.currentTemplate?.type === 'Tabs') {
                if (this.sortables.tabs) {
                    this.sortables.tabs.destroy();
                }
                this.sortables.tabs = Sortable.create(tabHeader, {
                    group: 'tabs',
                    animation: 150,
                    onEnd: (evt) => {
                        this.saveState('Reorder tabs');
                        const movedTab = this.currentTemplate.elements.splice(evt.oldIndex, 1)[0];
                        this.currentTemplate.elements.splice(evt.newIndex, 0, movedTab);
                        this.markAsModified();
                        this.updateTemplate();
                    }
                });
            }
        },

        initCanvasSortable() {
            this.$nextTick(() => {
                // Destroy existing sortables
                Object.values(this.sortables).forEach(sortable => {
                    if (sortable && sortable.destroy) sortable.destroy();
                });
                this.sortables = {};

                // Initialize main canvas
                if (this.currentTemplate?.type !== 'Tabs') {
                    const mainCanvas = document.getElementById('main-canvas');
                    if (mainCanvas) {
                        this.sortables.main = this.createSortable(mainCanvas, this.currentTemplate.elements);
                    }
                } else {
                    // Initialize tab content areas
                    this.currentTemplate.elements.forEach((tab, tabIndex) => {
                        const tabContent = document.getElementById(`tab-content-${tabIndex}`);
                        if (tabContent) {
                            this.sortables[`tab-${tabIndex}`] = this.createSortable(tabContent, tab.elements || []);
                        }
                    });
                }

                // Initialize group and container sortables
                this.initNestedSortables();
            });
        },

	initNestedSortables() {
           // Initialize sortables for groups and containers
           document.querySelectorAll('.group-drop-zone, .container-column').forEach(zone => {
               const containerId = zone.getAttribute('data-container-id');
               const subIndex = zone.getAttribute('data-sub-index');
               
               if (containerId) {
                   const container = this.findElementById(containerId);
                   if (container) {
                       const targetArray = this.getContainerTargetArray(container, subIndex ? parseInt(subIndex) : null);
                       if (targetArray) {
                           const sortableKey = `${containerId}-${subIndex || 'main'}`;
                           this.sortables[sortableKey] = this.createSortable(zone, targetArray);
                       }
                   }
               }
           });
	},

	createSortable(element, targetArray) {
	    return Sortable.create(element, {
	        group: 'editor',
	        animation: 150,
	        ghostClass: 'sortable-ghost',
	        chosenClass: 'sortable-chosen',
	        dragClass: 'sortable-drag',
	        filter: '.element-controls',
	        preventOnFilter: false,
		delay: 100,
		delayOnTouchOnly: true,
	        onAdd: (evt) => {
	            this.saveState('Add element');
	            const elementData = evt.item.getAttribute('data-element');
	            if (elementData) {
	                const template = JSON.parse(elementData);
	                const newElement = this.createElement(template);
	                targetArray.splice(evt.newIndex, 0, newElement);
	                evt.item.remove();
	            } else {
	                this.handleElementMove(evt, targetArray);
	            }
	            this.markAsModified();
	            this.updateTemplate();
	        },
		onUpdate: (evt) => {
	            this.saveState('Reorder elements');
	            const movedElement = targetArray.splice(evt.oldIndex, 1)[0];
	            targetArray.splice(evt.newIndex, 0, movedElement);
	            this.markAsModified();
	            this.updateTemplate();
	        },
	        onStart: (evt) => {
		    this.isDragMode = true;
	            if (!evt.item.getAttribute('data-element')) {
	                const elementId = this.getElementIdFromItem(evt.item);
	                evt.item.setAttribute('data-element-id', elementId);
	            }
	        },
		onEnd: (evt) => {
		    this.isDragMode = false; // Unlock Alpine
		    this.updateTemplate(); // Now Alpine can update
		}
	    });
	},

        handleElementMove(evt, targetArray) {
            const elementId = evt.item.getAttribute('data-element-id');
            if (elementId) {
                const element = this.findElementById(elementId);
                if (element) {
                    this.removeElementFromAnywhere(elementId);
                    targetArray.splice(evt.newIndex, 0, element);
                    evt.item.remove();
                }
            }
        },

	getElementIdFromItem(item) {
	    // Find element ID from the wrapper or element
	    const elementId = item.getAttribute('data-element-id');
	    if (elementId) return elementId;           
	    // Try to find it in child elements
	    const wrapper = item.querySelector('[data-element-id]');
	    return wrapper ? wrapper.getAttribute('data-element-id') : null;
	},

	removeElementFromAnywhere(elementId) {
           return this.deepRemoveElement(this.currentTemplate.elements, elementId);
	},

	deepRemoveElement(elements, targetId) {
           for (let i = 0; i < elements.length; i++) {
               const element = elements[i];
               
               if (element.id === targetId) {
                   elements.splice(i, 1);
                   return true;
               }
               
               if (element.elements) {
                   if ((element.type === 'Group' || element.type === 'Container') && element.layout === 'columns') {
                       // Groups/Containers with columns have arrays of arrays
                       for (let j = 0; j < element.elements.length; j++) {
                           if (Array.isArray(element.elements[j])) {
                               if (this.deepRemoveElement(element.elements[j], targetId)) {
                                   return true;
                               }
                           }
                       }
                   } else if (element.type === 'Group' || element.type === 'Container') {
                       // Groups/Containers with other layouts have simple arrays
                       if (this.deepRemoveElement(element.elements, targetId)) {
                           return true;
                       }
                   } else if (element.type === 'Tabs') {
                       // Tabs have elements array where each tab has elements
                       for (let tab of element.elements) {
                           if (tab.elements && this.deepRemoveElement(tab.elements, targetId)) {
                               return true;
                           }
                       }
                   } else if (Array.isArray(element.elements)) {
                       // Generic array handling
                       if (this.deepRemoveElement(element.elements, targetId)) {
                           return true;
                       }
                   }
               }
           }
           return false;
	},

	getContainerTargetArray(container, subIndex) {
           if (!container || !container.elements) return null;
           if ((container.type === 'Group' || container.type === 'Container') && container.layout === 'columns') {
               if (subIndex !== null && container.elements[subIndex]) {
                   return container.elements[subIndex];
               }
           } else {
               return container.elements;
           }
           return null;
	},

	async initializeData() {
            try {
		Utils.showNotification('Loading schemas and templates...', 'info');
		await DataManager.loadAll();
		this.schemas = await DataManager.getSchemas();
		if (Object.keys(this.schemas).length === 0) {
                   //Utils.showNotification('No schemas available', 'warning');
                   return;
		}
		this.selectedSchemaId = Object.keys(this.schemas)[0];
		this.availableTemplates = await DataManager.getTemplates();
		if (Object.keys(this.availableTemplates).length > 0) {
                    this.selectedTemplateId = Object.keys(this.availableTemplates)[0];
		}
            } catch (error) {
		Utils.showNotification(`Failed to load data: ${error.message}`, 'error');
		console.error('Template editor initialization error:', error);
            }
	},

	async handleUrlParameters() {
	    const urlParams = new URLSearchParams(window.location.search);
	    const schemaParam = urlParams.get('schema');
	    const templateParam = urlParams.get('template');

	    if ( schemaParam ) {
	        const schema = DataManager.getSchemaByIndex(schemaParam);
	        if ( schema ) {
	            this.selectedSchemaId = schema.id;
	            this.loadTemplatesForSchema();
	            if ( templateParam ) {
	                await this.$nextTick();
	                const template = DataManager.getTemplateByIndex(templateParam);
	                if (template && this.availableTemplates[template.id]) {
	                    this.selectedTemplateId = template.id;
	                    this.loadTemplate();
	                }
	            }
	        }
	    }
	},

	setupUndoManager() {
           this.undoManager = new Utils.UndoRedoManager(50);
           this.undoManager.setCurrentStateGetter(() => Utils.deepClone(this.currentTemplate));
           this.undoManager.onStateChange = () => {
               this.canUndo = this.undoManager.canUndo();
               this.canRedo = this.undoManager.canRedo();
           };
	},

	saveState(description) {
           if (this.undoManager && this.currentTemplate) {
               this.undoManager.saveState(description);
           }
	},

	undo() {
           if (this.undoManager && this.undoManager.canUndo()) {
               const previousState = this.undoManager.undo();
               if (previousState) {
                   this.currentTemplate = Utils.deepClone(previousState);
                   this.selectedElementId = null;
                   this.markAsModified();
                   this.updateTemplate();
               }
           }
	},

	redo() {
           if (this.undoManager && this.undoManager.canRedo()) {
               const nextState = this.undoManager.redo();
               if (nextState) {
                   this.currentTemplate = Utils.deepClone(nextState);
                   this.selectedElementId = null;
                   this.markAsModified();
                   this.updateTemplate();
               }
           }
	},

	onSchemaChanged() {
           this.loadTemplatesForSchema();
	},

	onTemplateChanged() {
           this.loadTemplate();
	},

	selectSchema(schemaId) {
           this.selectedSchemaId = schemaId;
           this.loadTemplatesForSchema();
	},

	selectTemplate(templateId) {
           this.selectedTemplateId = templateId;
           this.loadTemplate();
	},

	loadTemplatesForSchema() {
           this.availableTemplates = {};
           this.selectedTemplateId = '';
           this.currentTemplate = null;
           this.selectedElementId = null;
           this.isModified = false;
           if (!this.selectedSchemaId) {
               this.availableFields = [];
               return;
           }
           const schema = DataManager.getSchema(this.selectedSchemaId);
           if (schema) {
               const allTemplates = DataManager.getTemplates();
               this.availableTemplates = Object.fromEntries(
                   Object.entries(allTemplates).filter(([_, template]) => 
                       template.schema === schema.index
                   )
               );
               this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
           }
	},

	loadTemplate() {
           if (this.selectedTemplateId === '_new') {
               this.createNewTemplate();
               return;
           }
           if (!this.selectedTemplateId) {
               this.currentTemplate = null;
               this.selectedElementId = null;
               this.isModified = false;
               return;
           }
           const template = DataManager.getTemplate(this.selectedTemplateId);
           if (template) {
               this.currentTemplate = Utils.deepClone(template);
               this.selectedElementId = null;
               this.isModified = false;
               this.activeTemplateTab = 0;
               
               if (this.undoManager) {
                   this.undoManager.clear();
                   this.undoManager.saveState('Template loaded');
               }
               this.updateTemplate();
           }
	},

	createNewTemplate() {
           this.showCreateModal = true;
	},

	createTemplate() {
           if (!this.newTemplate.title || !this.newTemplate.schema) return;
           const template = {
               id: Utils.generateId(),
               title: this.newTemplate.title,
               schema: this.newTemplate.schema,
               type: this.newTemplate.type,
               elements: this.newTemplate.type === 'Tabs' ? [
                   { id: Utils.generateId(), type: 'Tab', label: 'Tab 1', elements: [] }
               ] : []
           };
           this.currentTemplate = template;
           this.selectedElementId = null;
           this.isModified = true;
           this.activeTemplateTab = 0;
           this.showCreateModal = false;
           this.newTemplate = { title: '', schema: '', type: 'VerticalLayout' };
           if (this.undoManager) {
               this.undoManager.clear();
               this.undoManager.saveState('Template created');
           }
           this.updateTemplate();
	},

	createElement(template) {
           const element = { 
               id: Utils.generateId(), 
               type: template.type, 
               label: template.name, 
               style: {},
               backgroundColor: '',
               borderColor: '',
               textColor: ''
           };

           if (template.type === 'Control') {
               element.scope = '';
               element.controlType = template.controlType || 'text';
               if (template.controlType === 'textarea') element.richText = false;
               if (template.controlType === 'select') element.optionsSource = '';
           } else if (template.type === 'Group') {
               element.elements = [];
               element.layout = 'vertical';
               element.columns = 2;
               element.gap = 'medium';
               element.style = 'plain';
               element.collapsible = false;
               element.defaultCollapsed = 'open';
           } else if (template.type === 'Container') {
               element.elements = [];
               element.layout = 'vertical';
               element.columns = 2;
               element.gap = 'medium';
           } else if (template.type === 'Tabs') {
               element.elements = [{ id: Utils.generateId(), type: 'Tab', label: 'Tab 1', elements: [] }];
           } else if (template.type === 'Array') {
               element.scope = '';
               element.elements = [];
               element.layout = 'vertical';
               element.addButtonText = 'Add Item';
               element.deleteButtonText = 'Delete';
           }
           
           return element;
	},

	addTabToTemplate() {
           if (!this.currentTemplate || this.currentTemplate.type !== 'Tabs') return;
           
           this.saveState('Add tab');
           const newTab = {
               id: Utils.generateId(),
               type: 'Tab',
               label: `Tab ${this.currentTemplate.elements.length + 1}`,
               elements: []
           };
           
           this.currentTemplate.elements.push(newTab);
           this.activeTemplateTab = this.currentTemplate.elements.length - 1;
           this.markAsModified();
           this.updateTemplate();
	},

	findElementById(id, elements = null) {
           if (!elements) elements = this.currentTemplate.elements;
           return Utils.findElementById(elements, id);
	},

	selectElement(elementId) {
	    if (this.isDragMode) return
	    this.selectedElementId = elementId;
	    if (this.selectedSchemaId) {
	        this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
	    }
	},

	getElementProperty(property) {
           if (!this.selectedElementId) return '';
           const element = this.findElementById(this.selectedElementId);
           return element ? element[property] || '' : '';
	},

	updateElementProperty(property, value) {
           if (!this.selectedElementId) return;
           const element = this.findElementById(this.selectedElementId);
           if (!element) return;

           element[property] = value;
           this.markAsModified();
           this.currentTemplate = { ...this.currentTemplate };
	},

	duplicateElement(elementId) {
           if (!elementId) return;
           
           this.saveState('Duplicate element');
           const element = this.findElementById(elementId);
           if (!element) return;
           
           const duplicate = Utils.deepClone(element);
           duplicate.id = Utils.generateId();
           
           if (duplicate.label) {
               duplicate.label = duplicate.label + ' Copy';
           } else {
               duplicate.label = (duplicate.type || 'Element') + ' Copy';
           }
           
           this.updateNestedIds(duplicate);
           
           const parentContainer = Utils.findElementParent(this.currentTemplate.elements, elementId);
           if (parentContainer) {
               parentContainer.push(duplicate);
           } else {
               this.currentTemplate.elements.push(duplicate);
           }
           
           this.markAsModified();
           this.updateTemplate();
	},

	updateNestedIds(element) {
           if (element.elements) {
               element.elements.forEach(child => {
                   child.id = Utils.generateId();
                   this.updateNestedIds(child);
               });
           }
	},

	deleteElement(elementId) {
           if (!elementId) return;
           
           this.saveState('Delete element');
           this.removeElementFromAnywhere(elementId);
           
           if (this.selectedElementId === elementId) {
               this.selectedElementId = null;
           }
           
           this.markAsModified();
           this.updateTemplate();
	},

	markAsModified() {
           this.isModified = true;
	},

	updateTemplate() {
	   if  ( this.isDragMode ) return
           this.markAsModified();
           this.currentTemplate = { ...this.currentTemplate };
           this.$nextTick(() => {
               this.initCanvasSortable();
           });
	},

	async saveTemplate() {
           if (!this.currentTemplate) {
               Utils.showNotification('No template to save', 'error');
               return;
           }
           
           if (!this.currentTemplate.title) {
               Utils.showNotification('Template must have a title', 'error');
               return;
           }

           try {
               Utils.showNotification('Saving template...', 'info');
               
               const templateId = await DataManager.saveTemplate(this.currentTemplate);
               
               this.availableTemplates[templateId] = Utils.deepClone(this.currentTemplate);
               this.selectedTemplateId = templateId;
               this.isModified = false;
               
               Utils.showNotification(`Template saved successfully`, 'success');
           } catch (error) {
               Utils.showNotification(`Failed to save template: ${error.message}`, 'error');
               console.error('Save template error:', error);
           }
	},

	exportTemplate() {
           if (!this.currentTemplate) {
               Utils.showNotification('No template to export', 'error');
               return;
           }
           DataManager.exportTemplate(this.selectedTemplateId);
           Utils.showNotification('Template exported', 'success');
	},

	previewTemplate() {
           if (!this.currentTemplate) {
               Utils.showNotification('No template to preview', 'error');
               return;
           }
           const templateJson = JSON.stringify(this.currentTemplate, null, 2);
           const previewWindow = window.open('', '_blank');
           previewWindow.document.write(`<html><head><title>Template Preview</title><style>body{font-family:Arial,sans-serif;padding:2rem}pre{background:#f5f5f5;padding:1rem;border-radius:4px;overflow:auto}</style></head><body><h1>Template Preview: ${this.currentTemplate.title}</h1><h2>JSON Output:</h2><pre>${templateJson}</pre></body></html>`);
	},

	importTemplate() {
           const input = document.createElement('input');
           input.type = 'file';
           input.accept = '.json';
           input.onchange = (e) => {
               const file = e.target.files[0];
               if (!file) return;

               const reader = new FileReader();
               reader.onload = (e) => {
                   try {
                       const importedData = JSON.parse(e.target.result);
                       this.handleTemplateImport(importedData);
                   } catch (error) {
                       Utils.showNotification('Invalid JSON file. Please check the file format.', 'error');
                       console.error('Import error:', error);
                   }
               };
               reader.onerror = () => {
                   Utils.showNotification('Error reading file', 'error');
               };
               reader.readAsText(file);
           };
           input.click();
	},

	handleTemplateImport(importedData) {
           if (!importedData || typeof importedData !== 'object') {
               Utils.showNotification('Invalid template data format', 'error');
               return;
           }
           
           if (!importedData.title) {
               Utils.showNotification('Template must have a title', 'error');
               return;
           }
           
           if (!importedData.elements || !Array.isArray(importedData.elements)) {
               Utils.showNotification('Template must have valid elements array', 'error');
               return;
           }
           
           const currentSchema = DataManager.getSchema(this.selectedSchemaId);
           if (importedData.schema && importedData.schema !== currentSchema.index) {
               const confirmMessage = `This template was designed for "${importedData.schema}" but you have "${currentSchema.index}" selected. Import anyway?`;
               if (!confirm(confirmMessage)) {
                   return;
               }
           }
           
           this.saveState('Template import');
           
           const templateData = {
               title: importedData.title + (importedData.title.includes('(Imported)') ? '' : ' (Imported)'),
               schema: currentSchema.index,
               type: importedData.type || 'VerticalLayout',
               elements: importedData.elements
           };
           
           this.currentTemplate = templateData;
           this.selectedElementId = null;
           this.isModified = true;
           this.activeTemplateTab = 0;
           
           Utils.showNotification(`Template "${templateData.title}" imported successfully`, 'success');
           this.updateTemplate();
	},

	renderElement( element, index )  {
	    return Utils.ElementRenderer.renderElement(element, {
		isPreview: true,
		selectedElementId: this.selectedElementId,
		getValue: () => '',
		instanceRef: this
	    });
	},

	toggleLeftPane() {
           this.leftPaneCollapsed = !this.leftPaneCollapsed;
	},

	toggleRightPane() {
           this.rightPaneCollapsed = !this.rightPaneCollapsed;
	},

	elementNeedsScope(elementType) {
	    return ['Control', 'LinearTrack', 'CircularTrack', 'Array', 'MultiStateToggle', 'SelectGroup', 'Image'].includes(elementType);
	},

	elementSupportsAlignment() {
	    const elementType = this.getElementProperty('type');
	    return ['Control', 'Group'].includes(elementType);
	},

	elementSupportsBackgroundColor() {
	    const type = this.getElementProperty('type');
	    return ['Group', 'Control', 'Array', 'LinearTrack', 'CircularTrack', 'MultiStateToggle', 'SelectGroup'].includes(type);
	},

	elementSupportsBorderColor() {
	    const type = this.getElementProperty('type');
	    return ['Group', 'Control', 'Array', 'LinearTrack', 'CircularTrack', 'Image'].includes(type);
	},

	elementSupportsTextColor() {
	    const type = this.getElementProperty('type');
	    return ['Control', 'Label', 'MultiStateToggle', 'SelectGroup'].includes(type);
	},

	elementSupportsTextSize() {
	    const type = this.getElementProperty('type');
	    const controlType = this.getElementProperty('controlType');
	    return type === 'Control' && ['text', 'number', 'date', 'textarea', 'select'].includes(controlType) || type === 'Label';
	},

	hasAnyColorSet() {
	    if (!this.selectedElementId) return false;
	    const element = this.findElementById(this.selectedElementId);
	    if (!element) return false;
	    return !!(element.backgroundColor || element.borderColor || element.textColor);
	},

	hasAnyAlignmentSet() {
	    if (!this.selectedElementId || !this.currentTemplate) return false;
	    const element = Utils.findElementById(this.currentTemplate.elements, this.selectedElementId);
	    if (!element) return false;
	    
	    return !!(element.layout || element.labelPosition || element.labelAlignment || 
	              element.textAlignment || element.inputAlignment || element.width);
	},

	isFormula(scope) {
	    return Utils.FormulaEngine.isFormula(scope);
	},

	isValidFormula( scope ) {
	    if (!scope) return true;
	    if (!this.isFormula(scope)) return scope.startsWith('@');    
	    try {
	        const fieldRefs = Utils.FormulaEngine.parseFieldReferences(scope);
	        return fieldRefs.every(ref => this.availableFields.some(field => field.path === ref));
	    } catch (e) {
	        return false;
	    }
	},

	get filteredFields() {
           const input = this.getElementProperty('scope') || '';
           const searchTerm = input.toLowerCase();
           
           return this.availableFields.filter(field => 
               field.path.toLowerCase().includes(searchTerm) || 
               field.label.toLowerCase().includes(searchTerm)
           ).sort((a, b) => a.path.localeCompare(b.path));
	},

	get filteredEnumFields() {
           const input = this.getElementProperty('optionsSource') || '';
           const lastAtIndex = input.lastIndexOf('@');
           if (lastAtIndex === -1) return [];
           const searchTerm = input.substring(lastAtIndex + 1).toLowerCase();

           const filtered = this.availableFields.filter(field => {
               const hasEnum = field.enum || field.type === 'array';
               const matchesSearch = field.path.toLowerCase().includes(searchTerm) || field.label.toLowerCase().includes(searchTerm);
               return hasEnum && matchesSearch;
           });
           return filtered.sort((a, b) => a.path.localeCompare(b.path));
	}
    }
}


function createDragDebugMonitor() {
   const display = document.createElement('div');
   display.id = 'drag-debug-monitor';
   display.style.cssText = 'position: absolute; top: 2px; left: 30%; background: black; color: white; padding: 5px; z-index: 9999; font-family: monospace; font-size: 11px; min-width: 300px; max-height: 200px; overflow-y: auto;';
   document.body.appendChild(display);
   
   function updateDebugInfo() {
	const now = new Date();
	const timestamp = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}.${now.getMilliseconds()}`;
       const editorInstance = window.editorInstance;
       if (!editorInstance) {
           display.innerHTML = 'Editor instance not found';
           return;
       }
       const sortableCount = Object.keys(editorInstance.sortables || {}).length;
       const mainSortable = editorInstance.sortables?.main;
       const isDragMode = editorInstance.isDragMode;
       display.innerHTML = `
	   <div><strong>Time:</strong> ${timestamp}</div>
           <div><strong>isDragMode:</strong> ${isDragMode}</div>
           <div><strong>Sortables Count:</strong> ${sortableCount}</div>
           <div><strong>Main Sortable:</strong> ${mainSortable ? 'EXISTS' : 'NULL'}</div>
           <div><strong>Main Canvas:</strong> ${document.getElementById('main-canvas') ? 'EXISTS' : 'NULL'}</div>
           <div><strong>Sortable Items:</strong> ${document.querySelectorAll('.sortable-item').length}</div>
           <div><strong>Canvas Elements:</strong> ${document.querySelectorAll('.canvas-element').length}</div>
           <div><strong>Selected Element:</strong> ${editorInstance.selectedElementId || 'none'}</div>
       `;
	const sortablesObj = editorInstance.sortables;
	const sortablesKeys = sortablesObj ? Object.keys(sortablesObj) : [];
	display.innerHTML += `
	    <div><strong>--- SORTABLES DEBUG ---</strong></div>
	    <div>Sortables object: ${sortablesObj ? 'EXISTS' : 'NULL'}</div>
	    <div>Sortables keys: [${sortablesKeys.join(', ')}]</div>
	`;

	// If sortables exist, inspect them
	if (sortablesObj && sortablesKeys.length > 0) {
	    sortablesKeys.forEach(key => {
	        const sortable = sortablesObj[key];
	        display.innerHTML += `
	            <div>${key}: ${sortable ? 'EXISTS' : 'NULL'}</div>
	            <div>  - Properties: ${sortable ? Object.keys(sortable).join(', ') : 'NONE'}</div>
	        `;
	    });
	}
   }
   setInterval(updateDebugInfo, 100);
}

document.addEventListener('alpine:init', () => { 
    Alpine.data('templateEditor', templateEditor); 
});

document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
        const appElement = document.querySelector('[x-data="templateEditor()"]');
        if ( appElement && appElement._x_dataStack ) {
            window.editorInstance = appElement._x_dataStack[0];
        }
createDragDebugMonitor();
    }, 100);
});
window.addEventListener('error', function(e) {
    console.error('JS Error:');
    console.error(e);
});
</script>

</body>
</html>