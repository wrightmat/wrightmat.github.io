<!DOCTYPE html>
<html lang="en" class="template-editor">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTRPG Template Editor</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
  <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script src="data.js"></script>
  <script src="utils.js"></script>
</head>

<body x-data="templateEditor()">

<div class="character-editor-container" :class="{ 'left-collapsed': leftPaneCollapsed, 'right-collapsed': rightPaneCollapsed, 'both-collapsed': leftPaneCollapsed && rightPaneCollapsed }">
        
    <!-- Unified Toolbar -->
    <div class="toolbar">
        <button class="toolbar-toggle" @click="toggleLeftPane" :class="{ 'active': !leftPaneCollapsed }">
            <span x-text="leftPaneCollapsed ? '‚ñ∂' : '‚óÄ'"></span>
            <span class="text-sm">Palette</span>
        </button>
        
        <h1>üìù Template Editor</h1>
        
	<div class="toolbar-actions">
	    <select x-model="selectedSchemaId" @change="selectSchema($event.target.value)" class="form-control">
	        <option value="">Select System...</option>
	        <template x-for="(schema, id) in schemas">
	            <option :value="id" x-text="schema.title"></option>
	        </template>
	    </select>
	    <select x-model="selectedTemplateId" @change="selectTemplate($event.target.value)" class="form-control" :disabled="!selectedSchemaId">
	        <option value="">Select Template...</option>
	        <option value="_new">+ Create New Template</option>
	        <template x-for="(template, id) in availableTemplates">
	            <option :value="id" x-text="template.title"></option>
	        </template>
	    </select>
	    <button class="btn btn-primary" @click="saveTemplate" :disabled="!currentTemplate || !isModified">üíæ Save</button>
	</div>
        
        <button class="toolbar-toggle" @click="toggleRightPane" :class="{ 'active': !rightPaneCollapsed }">
            <span class="text-sm">Properties</span>
            <span x-text="rightPaneCollapsed ? '‚óÄ' : '‚ñ∂'"></span>
        </button>
    </div>

    <!-- Left Pane - Element Palette -->
    <div class="left-pane" :class="{ 'collapsed': leftPaneCollapsed, 'show': leftPaneVisible }">

    <div class="pane-header">
        <h3 class="pane-title">üé® Element Palette</h3>
        <button class="pane-toggle" @click="toggleLeftPane">
            <span x-text="leftPaneCollapsed ? '‚ñ∂' : '‚óÄ'"></span>
        </button>
    </div>

    <div class="palette-content">
        <div class="element-group">
            <h4>Basic Elements</h4>
            <template x-for="element in basicElements">
                <div class="draggable-element" draggable="true" @dragstart="startDrag(element, $event)" @dragend="endDrag">
                    <span class="element-icon" x-text="element.icon"></span>
                    <span class="element-name" x-text="element.name"></span>
                </div>
            </template>
        </div>
        <div class="element-group">
            <h4>Layout Elements</h4>
            <template x-for="element in layoutElements">
                <div class="draggable-element" draggable="true" @dragstart="startDrag(element, $event)" @dragend="endDrag">
                    <span class="element-icon" x-text="element.icon"></span>
                    <span class="element-name" x-text="element.name"></span>
                </div>
            </template>
        </div>
        <div class="element-group">
            <h4>Advanced Elements</h4>
            <template x-for="element in advancedElements">
                <div class="draggable-element" draggable="true" @dragstart="startDrag(element, $event)" @dragend="endDrag">
                    <span class="element-icon" x-text="element.icon"></span>
                    <span class="element-name" x-text="element.name"></span>
                </div>
            </template>
        </div>
    </div>

    <div class="pane-header">
        <h3 class="pane-title">üîß Tools</h3>
    </div>
    <div class="tools-content">
        <!-- File Operations -->
        <div class="tool-section">
            <h4 class="tool-section-title">üìÇ File Operations</h4>
            <button class="btn btn-primary btn-full-width btn-with-margin" @click="importTemplate" :disabled="!selectedSchemaId">
                üì§ Import
            </button>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="exportTemplate" :disabled="!selectedTemplateId || selectedTemplateId === '_new'">
                üì• Export
            </button>
            <div class="tool-note">
                <small>Import template files or export current template design.</small>
            </div>
        </div>

        <!-- Template & Design -->
        <div class="tool-section">
            <h4 class="tool-section-title">üé® Template & Design</h4>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="previewTemplate" :disabled="!selectedTemplateId || selectedTemplateId === '_new'">
                üëÅÔ∏è Preview
            </button>
            <button class="btn btn-secondary btn-full-width btn-with-margin" @click="editSchema" :disabled="!selectedSchemaId">
                üìã Edit Schema
            </button>
            <p class="tool-description">Preview templates and manage data schemas</p>
        </div>

        <!-- History Management -->
        <div class="tool-section">
            <h4 class="tool-section-title">‚Ü∂ History</h4>
            <div class="undo-redo-controls">
                <button class="btn btn-secondary" @click="undo" :disabled="!canUndo" title="Undo last action (Ctrl+Z)">
                    ‚Ü∂ Undo (<span x-text="undoManager ? undoManager.undoStack.length : 0"></span>)
                </button>
                <button class="btn btn-secondary" @click="redo" :disabled="!canRedo" title="Redo last action (Ctrl+Y)">
                    ‚Ü∑ Redo (<span x-text="undoManager ? undoManager.redoStack.length : 0"></span>)
                </button>
            </div>
            <div class="tool-note">
                <small>Keyboard shortcuts: Ctrl+Z (undo), Ctrl+Y (redo)</small>
            </div>
        </div>
    </div>
    </div>

    <!-- Main Canvas Area -->
    <div class="main-content">
        <div class="main-content-inner">
            <template x-if="!currentTemplate">
                <div class="empty-state">
                    <h2>üé® Template Editor</h2>
                    <p>Select a system and template to start editing, or create a new template.</p>
                    <div class="empty-state-actions">
                        <button class="btn btn-primary" @click="this.createNewTemplate" :disabled="!selectedSchemaId">‚ûï Create New Template</button>
                    </div>
                </div>
            </template>
            <template x-if="currentTemplate">
                <div>
                    <div class="template-header">
                        <input type="text" x-model="currentTemplate.title" @input="markAsModified" class="template-title-input" placeholder="Template Title">
                        <span x-show="isModified" class="modified-indicator">‚Ä¢ Modified</span>
                    </div>
                        
                    <!-- Handle Tabs Layout at Template Level -->
                    <template x-if="currentTemplate.type === 'Tabs'">
                        <div class="template-layout-indicator">
                            <div class="template-layout-header">
                                <h3 class="template-layout-title">Tab Layout</h3>
                                <button class="btn btn-secondary btn-small" @click="addTabToTemplate">‚ûï Add Tab</button>
                            </div>
                            <div class="tab-container">
                                <div class="tab-header">
                                    <template x-for="(tab, index) in currentTemplate.elements">
                                        <button class="tab-button" :class="{ 'active': activeTemplateTab === index }" @click="activeTemplateTab = index" x-text="tab.label || ('Tab ' + (index + 1))"></button>
                                    </template>
                                </div>
                                <template x-for="(tab, index) in currentTemplate.elements">
                                    <div class="tab-content" :class="{ 'active': activeTemplateTab === index }">
                                        <div class="tab-drop-zone" :class="{ 'drag-over': dragOver && activeTemplateTab === index }" @dragover.prevent="handleTabDragOver($event, index)" @dragleave="handleDragLeave($event)" @drop.prevent="handleTabDrop($event, index)">
                                            <template x-if="!tab.elements || tab.elements.length === 0">
                                                <div class="drop-zone-placeholder">üéØ Drop elements here for this tab</div>
                                            </template>
                                            <template x-for="(element, elemIndex) in (tab.elements || [])">
                                                <div>
                                                    <div class="drag-placeholder" :class="{ 'show': showPlaceholder === elemIndex && activeTemplateTab === index }"></div>
                                                    <div x-html="renderElement(element, elemIndex)" @dragover.prevent.stop="handleElementDragOver($event, elemIndex)" @drop.prevent.stop="handleTabElementDrop($event, index, elemIndex)"></div>
                                                </div>
                                            </template>
                                            <div class="drag-placeholder" :class="{ 'show': showPlaceholder === (tab.elements ? tab.elements.length : 0) && activeTemplateTab === index }"></div>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                        
                    <!-- Handle Non-Tabs Layout -->
                    <template x-if="currentTemplate.type !== 'Tabs'">
                        <div class="drop-zone" :class="{ 'drag-over': dragOver }" @dragover.prevent="handleDragOver($event)" @dragleave="handleDragLeave($event)" @drop.prevent="handleDrop($event, currentTemplate.elements)">
                            <template x-if="currentTemplate.elements.length === 0">
                                <div class="drop-zone-placeholder">üéØ Drop elements here to start building your template</div>
                            </template>
                            <template x-for="(element, index) in currentTemplate.elements">
                                <div>
                                    <div class="drag-placeholder" :class="{ 'show': showPlaceholder === index }"></div>
                                    <div x-html="renderElement(element, index)" @dragover.prevent.stop="handleElementDragOver($event, index)" @drop.prevent.stop="handleElementDrop($event, index)"></div>
                                </div>
                            </template>
                            <div class="drag-placeholder" :class="{ 'show': showPlaceholder === currentTemplate.elements.length }"></div>
                        </div>
                    </template>
                </div>
            </template>
        </div>
    </div>

    <!-- Right Pane - Properties Panel -->
    <div class="right-pane" :class="{ 'collapsed': rightPaneCollapsed, 'show': rightPaneVisible }">
        <div class="pane-header">
            <h3 class="pane-title">‚öôÔ∏è Properties</h3>
            <button class="pane-toggle" @click="toggleRightPane">
                <span x-text="rightPaneCollapsed ? '‚óÄ' : '‚ñ∂'"></span>
            </button>
        </div>
    
        <div class="properties-scroll">
            <template x-if="selectedElementId && currentTemplate">
		<div class="property-group appearance-group" x-data="{ generalOpen: true }">
		    <div class="property-group-header" @click="generalOpen = !generalOpen">
		        <h4 class="property-group-title collapsible-title">
		            <span class="collapse-icon" :class="{ 'collapsed': !generalOpen }" x-text="generalOpen ? '‚ñº' : '‚ñ∂'"></span>
		            General
		        </h4>
		    </div>
		    <div class="appearance-content" x-show="generalOpen">
		        <div class="form-group">
		            <label class="property-label">Element Type</label>
                            <input type="text" :value="getElementProperty('type')" class="form-control form-control-readonly" readonly>
                        </div>
                        <template x-if="getElementProperty('type') === 'Control'">
                            <div class="form-group">
                                <label class="property-label">Control Type</label>
                                <select :value="getElementProperty('controlType')" @change="updateElementProperty('controlType', $event.target.value)" class="form-control">
                                    <option value="text">Text Input</option>
                                    <option value="number">Number Input</option>
				    <option value="date">Date Input</option>
                                    <option value="textarea">Textarea</option>
                                    <option value="select">Select</option>
                                    <option value="checkbox">Checkbox</option>
                                    <option value="combo">Combo Field</option>
                                </select>
                            </div>
                        </template>

                        <div x-show="elementNeedsScope(getElementProperty('type'))">
			    <div class="form-group">
				<label class="property-label">Scope</label>
				<div class="formula-input-container">
			            <input 
			            type="text" 
			            :value="getElementProperty('scope')" 
			            @input="updateElementProperty('scope', $event.target.value)"
			            @keydown="handleFormulaKeydown($event)"
			            @focus="showFieldSuggestions = true"
				    @blur="setTimeout(() => showFieldSuggestions = false, 300)"
			            class="form-control formula-input"
			            placeholder="@field.path or formula..."
			            autocomplete="off">
        
			            <!-- Field suggestions dropdown -->
			            <div x-show="showFieldSuggestions && filteredFields.length > 0" 
			             class="field-suggestions" 
			             x-transition:enter="transition ease-out duration-100"
			             x-transition:enter-start="opacity-0 scale-95"
			             x-transition:enter-end="opacity-100 scale-100"
			             x-transition:leave="transition ease-in duration-75"
			             x-transition:leave-start="opacity-100 scale-100"
			             x-transition:leave-end="opacity-0 scale-95">
			            <template x-for="field in filteredFields.slice(0, 50)">
			                <div class="field-suggestion" 
			                     @click="insertFieldReference(field.path)"
			                     x-text="field.label + ' (' + field.path + ')'">
			                </div>
			            </template>
			            </div>
			        </div>
    
			        <!-- Formula validation -->
			        <div x-show="getElementProperty('scope') && !isValidFormula(getElementProperty('scope'))" class="formula-error"> Invalid formula syntax </div>
    
			        <!-- Formula preview -->
			        <div x-show="getElementProperty('scope') && isFormula(getElementProperty('scope'))" class="formula-preview"> Formula: <code x-text="getElementProperty('scope')"></code> </div>
			    </div>
                        </div>

                        <div class="form-group">
                            <label class="property-label">Label</label>
                            <input type="text" :value="getElementProperty('label')" @input="updateElementProperty('label', $event.target.value)" class="form-control">
                        </div>
			<div x-show="getElementProperty('type') === 'Control' && getElementProperty('controlType') === 'textarea'">
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('richText') === true" @change="updateElementProperty('richText', $event.target.checked)">
			            <span>Rich Text (Markdown Editor)</span>
			        </label>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Container'">
			    <div class="form-group">
			        <label class="property-label">Layout Type</label>
			        <select :value="getElementProperty('layout') || 'columns'" @change="updateElementProperty('layout', $event.target.value)" class="form-control">
			            <option value="columns">Columns</option>
			            <option value="rows">Rows</option>
			            <option value="grid">Grid</option>
			            <option value="flexbox">Flexbox</option>
			        </select>
			    </div>
			    <div x-show="getElementProperty('layout') === 'columns'" class="form-group">
			        <label class="property-label">Number of Columns</label>
			        <select :value="getElementProperty('columns') || 2" @change="updateElementProperty('columns', parseInt($event.target.value))" class="form-control">
			            <option value="2">2 Columns</option>
			            <option value="3">3 Columns</option>
			            <option value="4">4 Columns</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Gap Size</label>
			        <select :value="getElementProperty('gap') || 'medium'" @change="updateElementProperty('gap', $event.target.value)" class="form-control">
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Group'">
			    <div class="form-group">
			        <label class="property-label">Layout Type</label>
			        <select :value="getElementProperty('layout') || 'vertical'" @change="updateElementProperty('layout', $event.target.value)" class="form-control">
			            <option value="vertical">Vertical</option>
			            <option value="horizontal">Horizontal</option>
			            <option value="grid">Grid</option>
			            <option value="columns">Columns</option>
			            <option value="combo-row">Combo Row (Tight)</option>
			            <option value="combo-compact">Combo Compact</option>
			        </select>
			    </div>
			    <div x-show="getElementProperty('layout') === 'columns'" class="form-group">
			        <label class="property-label">Number of Columns</label>
			        <select :value="getElementProperty('columns') || 2" @change="updateElementProperty('columns', parseInt($event.target.value))" class="form-control">
			            <option value="2">2 Columns</option>
			            <option value="3">3 Columns</option>
			            <option value="4">4 Columns</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Gap Size</label>
			        <select :value="getElementProperty('gap') || 'medium'" @change="updateElementProperty('gap', $event.target.value)" class="form-control">
			            <option value="none">None</option>
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Visual Style</label>
			        <select :value="getElementProperty('style') || 'plain'" @change="updateElementProperty('style', $event.target.value)" class="form-control">
			            <option value="plain">Plain</option>
			            <option value="fieldset">Fieldset (with border)</option>
			            <option value="card">Card</option>
			            <option value="subtle">Subtle Background</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('collapsible') === true" @change="updateElementProperty('collapsible', $event.target.checked)">
			            <span>Make Collapsible</span>
			        </label>
			    </div>
			    <div x-show="getElementProperty('collapsible') === true" class="form-group">
			        <label class="property-label">Default State</label>
			        <select :value="getElementProperty('defaultCollapsed') || 'open'" @change="updateElementProperty('defaultCollapsed', $event.target.value)" class="form-control">
			            <option value="open">Open</option>
			            <option value="collapsed">Collapsed</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Array'">
			    <div class="form-group">
			        <label class="property-label">Display Style</label>
			        <select :value="getElementProperty('displayStyle') || 'table'" @change="updateElementProperty('displayStyle', $event.target.value)" class="form-control">
			            <option value="table">Table</option>
			            <option value="cards">Cards</option>
			            <option value="compact">Compact List</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowAdd') !== false" @change="updateElementProperty('allowAdd', $event.target.checked)">
			            <span>Allow Adding Items</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowRemove') !== false" @change="updateElementProperty('allowRemove', $event.target.checked)">
			            <span>Allow Removing Items</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowReorder') !== false" @change="updateElementProperty('allowReorder', $event.target.checked)">
			            <span>Allow Drag & Drop Reordering</span>
			        </label>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'LinearTrack' || getElementProperty('type') === 'CircularTrack'">
                            <div class="form-group">
                                <label class="property-label">Field Path</label>
                                <select :value="getElementProperty('scope')" @change="updateElementProperty('scope', $event.target.value)" class="form-control">
                                    <option value="">Select a field...</option>
                                    <template x-for="field in availableFields">
                                        <option :value="field.path" x-text="field.label"></option>
                                    </template>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="property-label">Number of Segments</label>
                                <input type="number" :value="getElementProperty('segments') ? getElementProperty('segments') : 6" @input="updateElementProperty('segments', parseInt($event.target.value))" class="form-control" min="2" max="20">
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" :checked="getElementProperty('showCounter') !== false" @change="updateElementProperty('showCounter', $event.target.checked)">
                                    <span>Show Counter Text</span>
                                </label>
                            </div>
                        </div>

			<div x-show="getElementProperty('type') === 'ComboField'">
			    <div class="form-group">
			        <label class="property-label">Layout</label>
			        <select :value="getElementProperty('layout') || 'vertical'" @change="updateElementProperty('layout', $event.target.value)" class="form-control">
			            <option value="vertical">Vertical</option>
			            <option value="horizontal">Horizontal</option>
			            <option value="compact">Compact</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Size</label>
			        <select :value="getElementProperty('size') || 'medium'" @change="updateElementProperty('size', $event.target.value)" class="form-control">
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'MultiStateToggle'">
			    <div class="form-group">
			        <label class="property-label">Number of States</label>
			        <select :value="getElementProperty('states') || 2" @change="updateElementProperty('states', parseInt($event.target.value))" class="form-control">
			            <option value="2">2 States (Off/On)</option>
			            <option value="3">3 States (Off/On/Expert)</option>
			            <option value="4">4 States (Custom)</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Shape</label>
			        <select :value="getElementProperty('shape') || 'circle'" @change="updateElementProperty('shape', $event.target.value)" class="form-control">
			            <option value="circle">Circle</option>
			            <option value="square">Square</option>
			            <option value="diamond">Diamond</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Size</label>
			        <select :value="getElementProperty('size') || 'medium'" @change="updateElementProperty('size', $event.target.value)" class="form-control">
			            <option value="small">Small</option>
			            <option value="medium">Medium</option>
			            <option value="large">Large</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Label Position</label>
			        <select :value="getElementProperty('labelPosition') || 'right'" @change="updateElementProperty('labelPosition', $event.target.value)" class="form-control">
			            <option value="left">Left</option>
			            <option value="right">Right</option>
			            <option value="above">Above</option>
			            <option value="below">Below</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'SelectGroup'">
			    <div class="form-group">
			        <label class="property-label">Options Source</label>
			        <select :value="getElementProperty('optionsSource') || 'field'" @change="updateElementProperty('optionsSource', $event.target.value)" class="form-control">
			            <option value="field">From Schema Field</option>
			            <option value="static">Static List</option>
			        </select>
			    </div>
			    <div x-show="getElementProperty('optionsSource') === 'field'" class="form-group">
			        <label class="property-label">Field Path (Options)</label>
			        <select :value="getElementProperty('optionsScope')" @change="updateElementProperty('optionsScope', $event.target.value)" class="form-control">
			            <option value="">Select options field...</option>
			            <template x-for="field in availableFields">
			                <option :value="field.path" x-text="field.label"></option>
			            </template>
			        </select>
			    </div>
			    <div x-show="getElementProperty('optionsSource') === 'static'" class="form-group">
			        <label class="property-label">Static Options (comma-separated)</label>
			        <textarea :value="getElementProperty('staticOptions')" @input="updateElementProperty('staticOptions', $event.target.value)" class="form-control" placeholder="Option 1, Option 2, Option 3"></textarea>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Selected Values Field</label>
			        <select :value="getElementProperty('scope')" @change="updateElementProperty('scope', $event.target.value)" class="form-control">
			            <option value="">Select field for selected values...</option>
			            <template x-for="field in availableFields">
			                <option :value="field.path" x-text="field.label"></option>
			            </template>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Selection Type</label>
			        <select :value="getElementProperty('selectionType') || 'multi'" @change="updateElementProperty('selectionType', $event.target.value)" class="form-control">
			            <option value="single">Single Select</option>
			            <option value="multi">Multi Select</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Display Mode</label>
			        <select :value="getElementProperty('displayMode') || 'all'" @change="updateElementProperty('displayMode', $event.target.value)" class="form-control">
			            <option value="all">Show All Options</option>
			            <option value="selected-only">Show Selected Only</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Visual Style</label>
			        <select :value="getElementProperty('style') || 'pills'" @change="updateElementProperty('style', $event.target.value)" class="form-control">
			            <option value="pills">Pills</option>
			            <option value="tags">Tags</option>
			            <option value="buttons">Buttons</option>
			        </select>
			    </div>
			</div>

			<div x-show="getElementProperty('type') === 'Image'">
			    <div class="form-group">
			        <label class="property-label">Data Field (Optional)</label>
			        <select :value="getElementProperty('scope')" @change="updateElementProperty('scope', $event.target.value)" class="form-control">
			            <option value="">Static Image (URL only)</option>
			            <template x-for="field in availableFields">
			                <option :value="field.path" x-text="field.label"></option>
			            </template>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Image Source (Static)</label>
			        <input type="text" :value="getElementProperty('src')" @input="updateElementProperty('src', $event.target.value)" class="form-control" placeholder="Enter image URL">
			    </div>
			    <div class="form-group">
			        <label class="property-label">Alt Text</label>
			        <input type="text" :value="getElementProperty('alt')" @input="updateElementProperty('alt', $event.target.value)" class="form-control" placeholder="Descriptive text">
			    </div>
			    <div class="form-group">
			        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
			            <div>
			                <label class="property-label">Width (px)</label>
					<input type="number" :value="getElementProperty('width') || 150" @input="updateImageDimension('width', parseInt($event.target.value))" class="form-control" min="20" max="800">
			            </div>
			            <div>
			                <label class="property-label">Height (px)</label>
					<input type="number" :value="getElementProperty('height') || 150" @input="updateImageDimension('height', parseInt($event.target.value))" class="form-control" min="20" max="800">
			            </div>
			        </div>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Shape</label>
			        <select :value="getElementProperty('shape') || 'square'" @change="updateElementProperty('shape', $event.target.value)" class="form-control">
			            <option value="square">Square</option>
			            <option value="circle">Circle</option>
			            <option value="rounded">Rounded</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="property-label">Border Style</label>
			        <select :value="getElementProperty('borderStyle') || 'thin'" @change="updateElementProperty('borderStyle', $event.target.value)" class="form-control">
			            <option value="none">No Border</option>
			            <option value="thin">Thin Border</option>
			            <option value="thick">Thick Border</option>
			            <option value="accent">Accent Border</option>
			        </select>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('allowUpload') === true" @change="updateElementProperty('allowUpload', $event.target.checked)">
			            <span>Allow Upload in Character Sheet</span>
			        </label>
			    </div>
			    <div class="form-group">
			        <label class="checkbox-label">
			            <input type="checkbox" :checked="getElementProperty('maintainAspectRatio') === true" @change="updateElementProperty('maintainAspectRatio', $event.target.checked)">
			            <span>Maintain Aspect Ratio</span>
			        </label>
			    </div>
			</div>

                        <div x-show="getElementProperty('type') === 'Tab'">
                            <div class="form-group">
                                <label class="property-label">Tab Label</label>
                                <input type="text" :value="getElementProperty('label')" @input="updateElementProperty('label', $event.target.value)" class="form-control">
                            </div>
                        </div>
                    </div>

<div class="property-group appearance-group" x-data="{ appearanceOpen: false }" x-init="$watch('selectedElementId', () => { appearanceOpen = hasAnyColorSet(); })">
    <div class="property-group-header" @click="appearanceOpen = !appearanceOpen">
        <h4 class="property-group-title collapsible-title">
            <span class="collapse-icon" :class="{ 'collapsed': !appearanceOpen }" x-text="appearanceOpen ? '‚ñº' : '‚ñ∂'"></span>
            Appearance
        </h4>
    </div>
    
    <div class="appearance-content" x-show="appearanceOpen">
        <div class="color-property-group">
            <div class="color-property-header" x-show="elementSupportsBackgroundColor()">
                <label class="property-label">Background Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('backgroundColor') || '#ffffff'}`"></div>
                    <span class="color-value" x-text="getElementProperty('backgroundColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in colorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('backgroundColor') === color.value }"
                         @click="updateElementProperty('backgroundColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('backgroundColor') || '#ffffff'" 
                           @input="updateElementProperty('backgroundColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('backgroundColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>

        <div x-show="elementSupportsBorderColor()" class="color-property-group">
            <div class="color-property-header">
                <label class="property-label">Border Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('borderColor') || '#e5e7eb'}`"></div>
                    <span class="color-value" x-text="getElementProperty('borderColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in colorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('borderColor') === color.value }"
                         @click="updateElementProperty('borderColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('borderColor') || '#e5e7eb'" 
                           @input="updateElementProperty('borderColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('borderColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>

        <!-- Text Color -->
        <div x-show="elementSupportsTextColor()" class="color-property-group">
            <div class="color-property-header">
                <label class="property-label">Text Color</label>
                <div class="color-value-display">
                    <div class="color-swatch" :style="`background-color: ${getElementProperty('textColor') || '#374151'}`"></div>
                    <span class="color-value" x-text="getElementProperty('textColor') || 'Default'"></span>
                </div>
            </div>
            <div class="color-quick-picks">
                <template x-for="color in textColorPresets">
                    <div class="color-preset-mini" 
                         :style="`background-color: ${color.value}`" 
                         :class="{ 'selected': getElementProperty('textColor') === color.value }"
                         @click="updateElementProperty('textColor', color.value)"
                         :title="color.name"></div>
                </template>
                <label class="color-picker-button" title="Custom Color">
                    <input type="color" 
                           :value="getElementProperty('textColor') || '#374151'" 
                           @input="updateElementProperty('textColor', $event.target.value)"
                           class="color-input-hidden">
                    <span class="color-picker-icon">üé®</span>
                </label>
                <button class="btn-clear-mini" 
                        @click="updateElementProperty('textColor', '')"
                        title="Clear Color">√ó</button>
            </div>
        </div>
    </div>
</div>

                    <div class="property-group">
                        <h4 class="property-group-title">Actions</h4>
                        <button class="btn btn-secondary btn-full-width btn-with-margin" @click="duplicateElement(selectedElementId)">üìã Duplicate</button>
                        <button class="btn btn-danger btn-full-width" @click="deleteElement(selectedElementId)">üóëÔ∏è Delete</button>
                    </div>
                </div>
            </template>
            <template x-if="!selectedElementId">
                <div class="empty-state-small">Select an element to edit its properties</div>
            </template>
        </div>
    </div>
    
    <template x-if="showCreateModal">
        <div class="modal-overlay" @click="showCreateModal = false">
            <div class="modal" @click.stop>
                <div class="modal-header">
                    <h3>Create New Template</h3>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label>Template Title</label>
                        <input type="text" x-model="newTemplate.title" class="form-control" placeholder="Enter template title">
                    </div>
                    <div class="form-group">
                        <label>Game System</label>
                        <select x-model="newTemplate.schema" class="form-control">
                            <option value="">Select system...</option>
                            <template x-for="(schema, id) in schemas">
                                <option :value="id" x-text="schema.title"></option>
                            </template>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Layout Type</label>
                        <select x-model="newTemplate.type" class="form-control">
                            <option value="VerticalLayout">Vertical Layout</option>
                            <option value="HorizontalLayout">Horizontal Layout</option>
                            <option value="Tabs">Tabs Layout</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" @click="showCreateModal = false">Cancel</button>
                    <button class="btn btn-primary" @click="createTemplate" :disabled="!newTemplate.title || !newTemplate.schema">Create Template</button>
                </div>
            </div>
        </div>
    </template>
    
    <script>
        function templateEditor() {
            return {
		Utils: Utils,
                schemas: {},
                currentTemplate: null,
                selectedElementId: null,
                selectedSchemaId: '',
                selectedTemplateId: '',
                availableTemplates: {},
                availableFields: [],
                dragOver: false,
                showPlaceholder: -1,
                draggedElement: null,
                draggedElementId: null,
                isDraggingFromPalette: false,
                showCreateModal: false,
                isModified: false,
                activeTemplateTab: 0,
                leftPaneCollapsed: false,
                rightPaneCollapsed: false,
                leftPaneVisible: true,
                rightPaneVisible: true,
		dragTargetContainer: null,
		dragTargetSubContainer: null,
		groupPlaceholderIndex: -1,
                newTemplate: { title: '', schema: '', type: 'VerticalLayout' },
		undoManager: null,
		canUndo: false,
		canRedo: false,
		showFieldSuggestions: false,
                
                basicElements: [
                    { type: 'Control', name: 'Text Input', icon: 'üìù', controlType: 'text' },
                    { type: 'Control', name: 'Number Input', icon: 'üî¢', controlType: 'number' },
		    { type: 'Control', name: 'Date Input', icon: 'üìÖ', controlType: 'date' },
                    { type: 'Control', name: 'Textarea', icon: 'üìÑ', controlType: 'textarea' },
                    { type: 'Control', name: 'Select', icon: 'üìã', controlType: 'select' },
                    { type: 'Label', name: 'Label', icon: 'üìù' },
                    { type: 'Divider', name: 'Divider', icon: '‚ûñ' },
                ],
                layoutElements: [
                    { type: 'Group', name: 'Group', icon: 'üì¶' },
                    { type: 'Tabs', name: 'Tabs', icon: 'üìë' },
                ],
                advancedElements: [
                    { type: 'Array', name: 'Array/List', icon: 'üìö' },
                    { type: 'LinearTrack', name: 'Linear Track', icon: '‚ñ≠' },
                    { type: 'CircularTrack', name: 'Circular Clock', icon: 'üïê' },
		    { type: 'MultiStateToggle', name: 'Multi-State Toggle', icon: 'üéØ' },
		    { type: 'SelectGroup', name: 'Select Group', icon: 'üè∑Ô∏è' },
		    { type: 'Image', name: 'Image', icon: 'üñºÔ∏è' },
                ],

		colorPresets: [
		    { name: 'White', value: '#ffffff' },
		    { name: 'Light Gray', value: '#f8fafc' },
		    { name: 'Blue', value: '#3b82f6' },
		    { name: 'Green', value: '#059669' },
		    { name: 'Red', value: '#dc2626' },
		    { name: 'Orange', value: '#d97706' },
		    { name: 'Purple', value: '#7c3aed' },
		    { name: 'Yellow', value: '#eab308' },
		    { name: 'Pink', value: '#ec4899' },
		    { name: 'Indigo', value: '#4f46e5' },
		    { name: 'Teal', value: '#0d9488' },
		    { name: 'Black', value: '#111827' }
		],

		textColorPresets: [
		    { name: 'Dark Gray', value: '#374151' },
		    { name: 'Black', value: '#111827' },
		    { name: 'Blue', value: '#3b82f6' },
		    { name: 'Green', value: '#059669' },
		    { name: 'Red', value: '#dc2626' },
		    { name: 'Orange', value: '#d97706' },
		    { name: 'Purple', value: '#7c3aed' },
		    { name: 'Yellow', value: '#eab308' },
		    { name: 'Pink', value: '#ec4899' },
		    { name: 'Indigo', value: '#4f46e5' },
		    { name: 'Teal', value: '#0d9488' },
		    { name: 'White', value: '#ffffff' }
		],
                
async init() {
    await DataManager.loadAll();
    this.schemas = DataManager.getSchemas();
    
    // Handle URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const schemaParam = urlParams.get('schema');
    const templateParam = urlParams.get('template');
    
    if ( schemaParam ) {
        const schema = DataManager.getSchemaByIndex(schemaParam);
        if ( schema ) {
            this.selectedSchemaId = schema.id;
            this.loadTemplatesForSchema();
            
            if ( templateParam ) {
                await this.$nextTick();
                const template = DataManager.getTemplateByIndex(templateParam);
                if (template && this.availableTemplates[template.id]) {
                    this.selectedTemplateId = template.id;
                    this.loadTemplate();
                }
            }
        }
    }

    // Initialize undo/redo system
    this.initUndoRedo();

    // Add keyboard shortcuts
    this.setupKeyboardShortcuts();
},

// Formula and field suggestion handling
get filteredFields() {
    const input = this.getElementProperty('scope') || '';
    const lastAtIndex = input.lastIndexOf('@');
    if (lastAtIndex === -1) return [];
    
    const searchTerm = input.substring(lastAtIndex + 1).toLowerCase();
    
    const filtered = this.availableFields.filter(field => 
        field.path.toLowerCase().includes(searchTerm) ||
        field.label.toLowerCase().includes(searchTerm)
    );
    
    // Sort results: exact matches first, then by path length (shorter first), then alphabetically
    filtered.sort((a, b) => {
        const aPath = a.path.toLowerCase();
        const bPath = b.path.toLowerCase();
        
        // Exact path matches first
        if (aPath === searchTerm && bPath !== searchTerm) return -1;
        if (bPath === searchTerm && aPath !== searchTerm) return 1;
        
        // Paths that start with search term
        if (aPath.startsWith(searchTerm) && !bPath.startsWith(searchTerm)) return -1;
        if (bPath.startsWith(searchTerm) && !aPath.startsWith(searchTerm)) return 1;
        
        // Shorter paths first (root level fields like "spells" vs "spellcasting.spellSlots.level1")
        const aDots = (a.path.match(/\./g) || []).length;
        const bDots = (b.path.match(/\./g) || []).length;
        if (aDots !== bDots) return aDots - bDots;
        
        // Alphabetical
        return aPath.localeCompare(bPath);
    });
    
    return filtered;
},

isFormula(scope) {
    return Utils.FormulaEngine.isFormula(scope);
},

isValidFormula(scope) {
    if (!scope) return true;
    if (!this.isFormula(scope)) return scope.startsWith('@');
    
    try {
        // Basic syntax validation - try to parse field references
        const fieldRefs = Utils.FormulaEngine.parseFieldReferences(scope);
        return fieldRefs.every(ref => this.availableFields.some(field => field.path === ref));
    } catch (e) {
        return false;
    }
},

handleFormulaKeydown(event) {
    if (event.key === '@') {
        this.showFieldSuggestions = true;
    } else if (event.key === 'Escape') {
        this.showFieldSuggestions = false;
    } else if (event.key === 'ArrowDown' && this.showFieldSuggestions) {
        event.preventDefault();
        // Focus first suggestion
        const firstSuggestion = event.target.parentElement.querySelector('.field-suggestion');
        if (firstSuggestion) firstSuggestion.focus();
    }
},

insertFieldReference(fieldPath) {
    const currentScope = this.getElementProperty('scope') || '';
    const lastAtIndex = currentScope.lastIndexOf('@');
    
    let newValue;
    if (lastAtIndex !== -1) {
        // Replace the partial field reference after the last @
        newValue = currentScope.substring(0, lastAtIndex) + '@' + fieldPath;
    } else {
        // No @ found, append the field reference
        newValue = currentScope + (currentScope ? ' @' : '@') + fieldPath;
    }
    
    this.updateElementProperty('scope', newValue);
    this.showFieldSuggestions = false;
    
    // Re-focus the input after a short delay
    this.$nextTick(() => {
        const formulaInput = document.querySelector('.formula-input');
        if (formulaInput) {
            formulaInput.focus();
            formulaInput.setSelectionRange(newValue.length, newValue.length);
        }
    });
},

elementNeedsScope(elementType) {
    return ['Control', 'LinearTrack', 'CircularTrack', 'Array', 'MultiStateToggle', 'ComboField', 'Image'].includes(elementType);
},

elementSupportsBackgroundColor() {
    const type = this.getElementProperty('type');
    return ['Group', 'Control', 'Array', 'LinearTrack', 'CircularTrack', 'MultiStateToggle', 'SelectGroup'].includes(type);
},

elementSupportsBorderColor() {
    const type = this.getElementProperty('type');
    return ['Group', 'Control', 'Array', 'LinearTrack', 'CircularTrack', 'Image'].includes(type);
},

elementSupportsTextColor() {
    const type = this.getElementProperty('type');
    return ['Control', 'Label', 'MultiStateToggle', 'SelectGroup'].includes(type);
},

hasAnyColorSet() {
    if (!this.selectedElementId) return false;
    const element = this.findElementById(this.selectedElementId);
    if (!element) return false;
    return !!(element.backgroundColor || element.borderColor || element.textColor);
},

findElementById( id, elements = null ) {
    if (!elements) elements = this.currentTemplate.elements;
    return Utils.findElementById(elements, id);
},

selectSchema(schemaId) {
    this.selectedSchemaId = schemaId;
    this.loadTemplatesForSchema();
},

selectTemplate(templateId) {
    this.selectedTemplateId = templateId;
    this.loadTemplate();
},

loadTemplatesForSchema() {
    this.availableTemplates = {};
    this.selectedTemplateId = '';
    this.currentTemplate = null;
    this.selectedElementId = null;
    this.isModified = false;

    if (!this.selectedSchemaId) {
        this.availableFields = [];
        return;
    }

    // Find templates that reference this schema by index
    const schema = DataManager.getSchema(this.selectedSchemaId);
    if (schema) {
        const allTemplates = DataManager.getTemplates();
        this.availableTemplates = Object.fromEntries(
            Object.entries(allTemplates).filter(([_, template]) => 
                template.schema === schema.index
            )
        );
        this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
    }
},

loadTemplate() {
    if (this.selectedTemplateId === '_new') {
        this.createNewTemplate();
        return;
    }
    if (!this.selectedTemplateId) {
        this.currentTemplate = null;
        this.selectedElementId = null;
        this.isModified = false;
        return;
    }
    const template = DataManager.getTemplate(this.selectedTemplateId);
    if (template) {
	this.currentTemplate = Utils.deepClone(template);
	this.selectedElementId = null;
	this.isModified = false;
	this.activeTemplateTab = 0;
	this.ensureElementIds(this.currentTemplate.elements);
	// Clear undo/redo history and save the loaded state as initial state
	if (this.undoManager) {
	    this.undoManager.clear();
	    this.undoManager.saveState(this.currentTemplate, 'Template loaded');
	}
	// Set up drop zone listeners after template loads
	this.$nextTick(() => {
	    this.setupDropZoneListeners();
	});
    }
},
                
                toggleLeftPane() {
                    this.leftPaneCollapsed = !this.leftPaneCollapsed;
                    this.leftPaneVisible = !this.leftPaneVisible;
                },

                toggleRightPane() {
                    this.rightPaneCollapsed = !this.rightPaneCollapsed;
                    this.rightPaneVisible = !this.rightPaneVisible;
                },
                
                ensureElementIds(elements) {
                    elements.forEach(element => {
                        if (!element.id) element.id = Utils.generateId();
                        if (element.elements) this.ensureElementIds(element.elements);
                        if (element.type === 'Tab' && !element.id) {
                            element.id = Utils.generateId();
                        }
                    });
                },
                
                createNewTemplate() {
                    this.newTemplate = { title: '', schema: this.selectedSchemaId || '', type: 'VerticalLayout' };
                    this.showCreateModal = true;
                },
                
                createTemplate() {
                    if (!this.newTemplate.title || !this.newTemplate.schema) {
                        Utils.showNotification('Please fill in all required fields', 'error');
                        return;
                    }
                    const templateId = Utils.generateId();
                    const template = { title: this.newTemplate.title, schema: this.newTemplate.schema, type: this.newTemplate.type, elements: [] };
                    
                    this.selectedSchemaId = this.newTemplate.schema;
                    this.availableTemplates = DataManager.getTemplatesForSchema(this.selectedSchemaId);
                    this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
                    
                    this.availableTemplates[templateId] = template;
                    this.currentTemplate = template;
                    this.selectedTemplateId = templateId;
                    this.isModified = true;
                    this.showCreateModal = false;
                    
                    this.$nextTick(() => {
                        this.availableTemplates = { ...this.availableTemplates };
                    });
                    
                    Utils.showNotification('New template created', 'success');
                },
                
                markAsModified() { 
                    this.isModified = true; 
                },
                
                getElementProperty( property ) {
                    if (!this.selectedElementId) return '';
                    const element = this.findElementById(this.selectedElementId);
                    return element ? (element[property] || '') : '';
                },
                
getSchemaFieldLabelFromFormula(scopeOrFormula) {
    if (!this.selectedSchemaId || !scopeOrFormula) {
        return null;
    }
    
    // If it's a formula, try to extract the primary field reference
    if (Utils.FormulaEngine.isFormula(scopeOrFormula)) {
        const fieldRefs = Utils.FormulaEngine.parseFieldReferences(scopeOrFormula);
        if (fieldRefs.length === 1) {
            // Single field reference in formula - use that field's label
            return this.getSchemaFieldLabel(fieldRefs[0]);
        } else if (fieldRefs.length > 1) {
            // Multiple field references - create a generic label
            return "Calculated Value";
        }
        return "Formula Result";
    }
    
    // Simple field reference
    if (scopeOrFormula.startsWith('@')) {
        const fieldPath = scopeOrFormula.substring(1);
        return this.getSchemaFieldLabel(fieldPath);
    }
    
    // Legacy format - use existing method
    return this.getSchemaFieldLabel(scopeOrFormula);
},

updateElementProperty(property, value) {
    this.saveState('Property change: ' + property);
    if (!this.selectedElementId) return;
    const element = this.findElementById(this.selectedElementId);
    if (!element) return;
    
    // Auto-populate label when scope is selected
// Auto-populate label when scope is selected
if (property === 'scope' && value) {
    // Only auto-populate if the current label is empty, default, or was previously auto-generated
    const currentLabel = element.label || '';
    const isEmpty = !currentLabel || currentLabel === 'Field Label';
    
    // Check if current label looks like it was auto-generated from scope
    const wasAutoGenerated = currentLabel && value.includes('.') && 
        (currentLabel.toLowerCase().includes(value.split('.').pop().toLowerCase()) ||
         currentLabel === this.getSchemaFieldLabelFromFormula(value));
    
    if (isEmpty || wasAutoGenerated) {
        const schemaLabel = this.getSchemaFieldLabelFromFormula(value);
        if (schemaLabel && schemaLabel !== currentLabel) {
            element.label = schemaLabel;
        }
    }
}
    
    // Handle layout changes for Groups
    if (property === 'layout' && element.type === 'Group') {
        element[property] = value;
        // Ensure proper structure after layout change
        this.ensureContainerStructure(element);
        this.markAsModified();
        this.currentTemplate = { ...this.currentTemplate };
        this.$nextTick(() => {
            this.setupDropZoneListeners();
        });
        return;
    }
    
    element[property] = value;
    this.markAsModified();
    this.currentTemplate = { ...this.currentTemplate };
},

getSchemaFieldLabel(fieldPath) {
    if (!this.selectedSchemaId || !fieldPath) {
        return null;
    }
    
    const schema = DataManager.getSchema(this.selectedSchemaId);
    if (!schema) {
        return null;
    }
    
    // Handle dot notation paths (new format)
    if (fieldPath.includes('.')) {
        const pathParts = fieldPath.split('.');
        let current = schema;
        let label = '';
        
        for (let i = 0; i < pathParts.length; i++) {
            const part = pathParts[i];
            if (current.properties && current.properties[part]) {
                current = current.properties[part];
                const partLabel = current.label || Utils.generateFieldName(part);
                label = label ? `${label} > ${partLabel}` : partLabel;
            } else {
                // Path not found in schema
                return Utils.generateFieldName(pathParts[pathParts.length - 1]);
            }
        }
        
        return label;
    }
    
    // Handle legacy format (existing logic)
    let pathParts;
    if (fieldPath.startsWith('#/properties/')) {
        pathParts = fieldPath.replace('#/properties/', '').split('/properties/');
    } else {
        pathParts = [fieldPath];
    }
    
    let current = schema;
    let label = '';
    
    for (let i = 0; i < pathParts.length; i++) {
        const part = pathParts[i];
        if (current.properties && current.properties[part]) {
            current = current.properties[part];
            const partLabel = current.label || Utils.generateFieldName(part);
            label = label ? `${label} > ${partLabel}` : partLabel;
        } else {
            return Utils.generateFieldName(part);
        }
    }
    
    return label;
},

generateFieldNameFromPath(path) {
    const fieldName = path.split('/').pop();
    return fieldName.replace(/([A-Z])/g, ' $1')
                   .replace(/^./, str => str.toUpperCase())
                   .replace(/([a-z])([A-Z])/g, '$1 $2');
},

                startDrag( element, event ) {
                    this.draggedElement = element;
                    this.isDraggingFromPalette = true;
                    event.dataTransfer.effectAllowed = 'copy';
                },
                
                startCanvasDrag( elementId, event ) {
                    event.stopPropagation();
                    this.draggedElementId = elementId;
                    this.isDraggingFromPalette = false;
                    event.dataTransfer.effectAllowed = 'move';
                },
                
                endDrag() {
                    this.draggedElement = null;
                    this.draggedElementId = null;
                    this.isDraggingFromPalette = false;
                    this.dragOver = false;
                    this.showPlaceholder = -1;
                },
                
handleDrop(event, targetArray) {
    this.saveState('Add/move element');
    event.preventDefault();
    event.stopPropagation();
    
    // If we have a specific target container (including groups), handle it differently
    if (this.dragTargetContainer) {
        const container = this.findElementById(this.dragTargetContainer);
        if (container) {
            const actualTargetArray = this.getContainerTargetArray(container, this.dragTargetSubContainer);
            if (actualTargetArray) {
                targetArray = actualTargetArray;
            }
        }
    }
    
    const dropIndex = this.showPlaceholder >= 0 ? this.showPlaceholder : targetArray.length;
    
    if (this.isDraggingFromPalette && this.draggedElement) {
        const newElement = this.createElement(this.draggedElement);
        targetArray.splice(dropIndex, 0, newElement);
        this.markAsModified();
    } else if (!this.isDraggingFromPalette && this.draggedElementId) {
        const element = this.findElementById(this.currentTemplate.elements, this.draggedElementId);
        if (element) {
            Utils.removeElementById(this.currentTemplate.elements, this.draggedElementId);
            targetArray.splice(dropIndex, 0, element);
            this.markAsModified();
        }
    }
    
    this.dragOver = false;
    this.showPlaceholder = -1;
    this.dragTargetContainer = null;
    this.dragTargetSubContainer = null;
    this.updateTemplate();
},
                
                handleDragOver(event) {
                    this.dragOver = true;
                    this.showPlaceholder = this.currentTemplate.elements.length;
                },
                
                handleDragLeave(event) {
                    if (!event.currentTarget.contains(event.relatedTarget)) {
                        this.dragOver = false;
                        this.showPlaceholder = -1;
                    }
                },
                
                handleElementDragOver(event, index) {
                    event.preventDefault();
                    event.stopPropagation();
                    const rect = event.currentTarget.getBoundingClientRect();
                    const midpoint = rect.top + rect.height / 2;
                    this.showPlaceholder = event.clientY < midpoint ? index : index + 1;
                },
                
                handleElementDrop(event, index) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.handleDrop(event, this.currentTemplate.elements);
                },

// Replace dragTargetGroup, dragTargetContainer, etc. with:
dragTargetContainer: null,
dragTargetSubContainer: null, // For column index, etc.

handleContainerDragOver(event, containerId, subIndex = null) {
    event.preventDefault();
    event.stopPropagation();
    
    this.dragTargetContainer = containerId;
    this.dragTargetSubContainer = subIndex;
    this.dragOver = true;
    
    // Add visual feedback
    const selector = subIndex !== null 
        ? `[data-container-id="${containerId}"][data-sub-index="${subIndex}"]`
        : `[data-container-id="${containerId}"]`;
    
    // Remove drag-over class from all zones
    document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.classList.remove('drag-over');
    });
    
    // Add drag-over class to current target
    const targetZone = document.querySelector(selector);
    if (targetZone) {
        targetZone.classList.add('drag-over');
    }
    
    const container = this.findElementById(containerId);
    if (!container) return;
    
    // Get the target array for dropping
    const targetArray = this.getContainerTargetArray(container, subIndex);
    if (!targetArray) return;
    
    // Determine drop position based on mouse position
    this.calculateDropPosition(event, targetArray);
    this.updateAllPlaceholders();
},

handleContainerDrop(event, containerId, subIndex = null) {
    this.saveState('Add/move element');
    event.preventDefault();
    event.stopPropagation();
    
    const container = this.findElementById(containerId);
    if (!container) return;
    
    const targetArray = this.getContainerTargetArray(container, subIndex);
    if (!targetArray) return;
    
    const dropIndex = this.showPlaceholder >= 0 ? this.showPlaceholder : targetArray.length;
    
    if (this.isDraggingFromPalette && this.draggedElement) {
        const newElement = this.createElement(this.draggedElement);
        targetArray.splice(dropIndex, 0, newElement);
        this.markAsModified();
    } else if (!this.isDraggingFromPalette && this.draggedElementId) {
        const element = this.findElementById(this.draggedElementId);
        if (element) {
            // More thorough removal - search everywhere
            const removed = this.removeElementFromAnywhere(this.draggedElementId);
            if (removed) {
                targetArray.splice(dropIndex, 0, element);
                this.markAsModified();
            }
        }
    }
    
    this.cleanupDragState();
},

removeElementFromAnywhere(elementId) {
    // Use the deep removal method directly
    const removed = this.deepRemoveElement(this.currentTemplate.elements, elementId);
    return removed;
},

deepRemoveElement(elements, targetId) {
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        
        if (element.id === targetId) {
            elements.splice(i, 1);
            return true;
        }
        
        if (element.elements) {
            if ((element.type === 'Group' || element.type === 'Container') && element.layout === 'columns') {
                // Groups/Containers with columns have arrays of arrays
                for (let j = 0; j < element.elements.length; j++) {
                    if (Array.isArray(element.elements[j])) {
                        if (this.deepRemoveElement(element.elements[j], targetId)) {
                            return true;
                        }
                    }
                }
            } else if (element.type === 'Group' || element.type === 'Container') {
                // Groups/Containers with other layouts have simple arrays
                if (this.deepRemoveElement(element.elements, targetId)) {
                    return true;
                }
            } else if (Array.isArray(element.elements)) {
                // Fallback for other types with elements
                if (this.deepRemoveElement(element.elements, targetId)) {
                    return true;
                }
            }
        }
    }
    return false;
},

handleContainerDragLeave(event) {
    if (!event.currentTarget.contains(event.relatedTarget)) {
        this.dragTargetContainer = null;
        this.dragTargetSubContainer = null;
        this.updateAllPlaceholders();
    }
},

getContainerTargetArray(container, subIndex = null) {
    this.ensureContainerStructure(container);
    
    if (container.type === 'Group' && container.layout === 'columns' && subIndex !== null) {
        // Group with columns layout - target specific column
        return container.elements[subIndex];
    } else if (container.type === 'Group') {
        // Group with other layouts - target main elements array
        if (!container.elements) container.elements = [];
        return container.elements;
    } else if (container.type === 'Container') {
        // Legacy Container support - treat as Group
        this.ensureContainerStructure(container);
        if (container.layout === 'columns' && subIndex !== null) {
            return container.elements[subIndex];
        }
        return container.elements;
    }
    return null;
},

ensureContainerStructure(container) {
    if (!container.elements) container.elements = [];
    
    if ((container.type === 'Group' || container.type === 'Container') && container.layout === 'columns') {
        const columns = container.columns || 2;
        
        // If switching TO columns layout and elements is a flat array, preserve elements
        if (!Array.isArray(container.elements[0])) {
            const flatElements = [...container.elements];
            container.elements = [];
            for (let i = 0; i < columns; i++) {
                container.elements.push([]);
            }
            // Put all existing elements in the first column
            if (flatElements.length > 0) {
                container.elements[0] = flatElements;
            }
        } else {
            // Ensure we have the right number of column arrays
            while (container.elements.length < columns) {
                container.elements.push([]);
            }
            
            // Ensure each column is an array
            for (let i = 0; i < columns; i++) {
                if (!Array.isArray(container.elements[i])) {
                    container.elements[i] = [];
                }
            }
            
            // Remove extra columns if we reduced the column count
            if (container.elements.length > columns) {
                // Move elements from removed columns to the last remaining column
                const extraElements = container.elements.slice(columns).flat();
                if (extraElements.length > 0) {
                    container.elements[columns - 1].push(...extraElements);
                }
                container.elements = container.elements.slice(0, columns);
            }
        }
    } else if (container.type === 'Group' || container.type === 'Container') {
        // Groups/Containers with non-column layouts need simple arrays
        if (container.elements.length > 0 && Array.isArray(container.elements[0])) {
            // Switching FROM columns layout - flatten the arrays
            container.elements = container.elements.flat();
        }
        if (!Array.isArray(container.elements)) {
            container.elements = [];
        }
    }
},

calculateDropPosition(event, targetArray) {
    // Find all rendered elements in the current drop target
    const containerSelector = this.dragTargetSubContainer !== null 
        ? `[data-container-id="${this.dragTargetContainer}"][data-sub-index="${this.dragTargetSubContainer}"]`
        : `[data-container-id="${this.dragTargetContainer}"]`;
    
    const containerElement = document.querySelector(containerSelector);
    if (!containerElement) {
        this.showPlaceholder = targetArray.length;
        return;
    }
    
    const elementWrappers = containerElement.querySelectorAll('.element-wrapper, .group-element-wrapper, .container-element-wrapper');
    
    let dropIndex = targetArray.length; // Default to end
    
    for (let i = 0; i < elementWrappers.length; i++) {
        const elemRect = elementWrappers[i].getBoundingClientRect();
        const elemMidY = elemRect.top + elemRect.height / 2;
        
        if (event.clientY < elemMidY) {
            dropIndex = i;
            break;
        }
    }
    
    this.showPlaceholder = dropIndex;
},

updateAllPlaceholders() {
    // Hide all placeholders
    document.querySelectorAll('.drag-placeholder').forEach(p => {
        p.classList.remove('show');
    });
    
    // Show the appropriate placeholder
    if (this.dragTargetContainer && this.showPlaceholder >= 0) {
        const selector = this.dragTargetSubContainer !== null 
            ? `[data-container-id="${this.dragTargetContainer}"][data-sub-index="${this.dragTargetSubContainer}"]`
            : `[data-container-id="${this.dragTargetContainer}"]`;
        
        const containerElement = document.querySelector(selector);
        if (containerElement) {
            const elementWrappers = containerElement.querySelectorAll('.element-wrapper, .group-element-wrapper, .container-element-wrapper');
            
            if (this.showPlaceholder < elementWrappers.length) {
                const placeholder = elementWrappers[this.showPlaceholder].querySelector('.drag-placeholder');
                if (placeholder) placeholder.classList.add('show');
            } else {
                const finalPlaceholder = containerElement.querySelector('.final-placeholder');
                if (finalPlaceholder) finalPlaceholder.classList.add('show');
            }
        }
    }
},

cleanupDragState() {
    this.dragOver = false;
    this.showPlaceholder = -1;
    this.dragTargetContainer = null;
    this.dragTargetSubContainer = null;
    
    // Remove all drag-over classes
    document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.classList.remove('drag-over');
    });
    
    this.updateAllPlaceholders();
    this.updateTemplate();
},

isDraggingOverMainArea() {
    // Check if we're still dragging over any valid drop area
    return this.dragTargetGroup !== null;
},
                
                addTabToTemplate() {
                    if (this.currentTemplate.type === 'Tabs') {
			this.saveState('Add tab');
                        const newTab = {
                            id: Utils.generateId(),
                            type: 'Tab',
                            label: `Tab ${this.currentTemplate.elements.length + 1}`,
                            elements: []
                        };
                        this.currentTemplate.elements.push(newTab);
                        this.markAsModified();
                        this.updateTemplate();
			this.markAsModified();
                    }
                },
                
                handleTabDragOver(event, tabIndex) {
                    this.dragOver = true;
                    this.activeTemplateTab = tabIndex;
                    this.showPlaceholder = this.currentTemplate.elements[tabIndex].elements ? this.currentTemplate.elements[tabIndex].elements.length : 0;
                },
                
                handleTabDrop(event, tabIndex) {
		    this.saveState('Add/move element');
                    event.preventDefault();
                    event.stopPropagation();
                    const tab = this.currentTemplate.elements[tabIndex];
                    if (!tab.elements) tab.elements = [];
                    
                    const dropIndex = this.showPlaceholder >= 0 ? this.showPlaceholder : tab.elements.length;
                    
                    if (this.isDraggingFromPalette && this.draggedElement) {
                        const newElement = this.createElement(this.draggedElement);
                        tab.elements.splice(dropIndex, 0, newElement);
                        this.markAsModified();
                    } else if (!this.isDraggingFromPalette && this.draggedElementId) {
                        const element = this.findElementById(this.currentTemplate.elements, this.draggedElementId);
                        if (element) {
                            Utils.removeElementById(this.currentTemplate.elements, this.draggedElementId);
                            tab.elements.splice(dropIndex, 0, element);
                            this.markAsModified();
                        }
                    }
                    
                    this.dragOver = false;
                    this.showPlaceholder = -1;
                    this.updateTemplate();
                },
                
                handleTabElementDrop(event, tabIndex, elemIndex) {
                    event.preventDefault();
                    event.stopPropagation();
                    const tab = this.currentTemplate.elements[tabIndex];
                    if (!tab.elements) tab.elements = [];
                    this.handleDrop(event, tab.elements);
                },
                
                handleGroupDrop(event, groupId) {
                    event.preventDefault();
                    event.stopPropagation();
                    
                    const group = this.findElementById(this.currentTemplate.elements, groupId);
                    if (!group || !group.elements) return;
                    
                    if (this.isDraggingFromPalette && this.draggedElement) {
                        const newElement = this.createElement(this.draggedElement);
                        group.elements.push(newElement);
                        this.markAsModified();
                        this.updateTemplate();
                    } else if (!this.isDraggingFromPalette && this.draggedElementId) {
                        const element = this.findElementById(this.currentTemplate.elements, this.draggedElementId);
                        if (element) {
                            Utils.removeElementById(this.currentTemplate.elements, this.draggedElementId);
                            group.elements.push(element);
                            this.markAsModified();
                            this.updateTemplate();
                        }
                    }
                },
                
                createElement( template ) {
		    const element = { 
		        id: Utils.generateId(), 
		        type: template.type, 
		        label: template.name, 
		        style: {},
		        backgroundColor: '',
		        borderColor: '',
			textColor: ''
		    };

                    if ( template.type === 'Control' ) {
                        element.scope = '';
                        element.controlType = template.controlType || 'text';
			if ( template.controlType === 'textarea' ) element.richText = false;
		    } else if ( template.type === 'Group' ) {
			element.elements = [];
			element.layout = 'vertical';
			element.columns = 2;
			element.gap = 'medium';
			element.style = 'plain';
			element.collapsible = false;
			element.defaultCollapsed = 'open';
			this.$nextTick(() => {
			    this.$nextTick(() => { this.setupDropZoneListeners(); });
			});
                    } else if ( template.type === 'Tabs' ) {
                        element.elements = [{  id: Utils.generateId(), type: 'Tab', label: 'Tab 1', elements: [] }];
                    } else if ( template.type === 'Array' ) {
                        element.scope = '';
			element.displayStyle = 'table';
			element.allowAdd = true;
			element.allowRemove = true;
			element.allowReorder = true;
			element.itemTemplate = 'default';
                    } else if ( template.type === 'LinearTrack' || template.type === 'CircularTrack' ) {
                        element.scope = '';
                        element.segments = 6;
                        element.showCounter = true;
		    } else if ( template.type === 'ComboField' ) {
			element.scope = '';
			element.layout = 'vertical';
			element.size = 'medium';
		    } else if ( template.type === 'MultiStateToggle' ) {
			element.scope = '';
			element.states = 2;
			element.shape = 'circle';
			element.size = 'medium';
			element.labelPosition = 'right';
		    } else if ( template.type === 'SelectGroup' ) {
			element.scope = '';
			element.optionsSource = 'field';
			element.optionsScope = '';
			element.staticOptions = '';
			element.selectionType = 'multi';
			element.displayMode = 'all';
			element.style = 'pills';
		    } else if ( template.type === 'Image' ) {
			element.scope = '';
			element.src = '';
			element.alt = '';
			element.width = 150;
			element.height = 150;
			element.shape = 'square';
			element.borderStyle = 'thin';
			element.allowUpload = true;
			element.maintainAspectRatio = true;
                    }
                    return element;
                },
                
		selectElement( elementId ) {
		    this.selectedElementId = elementId;
		    if ( this.selectedSchemaId ) {
		        this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
		    }
		},
                
deleteElement( elementId ) {
    if ( elementId ) {
        this.saveState('Delete element');
        // Use the same deep removal method as drag and drop
        const removed = this.removeElementFromAnywhere(elementId);
        if (removed && this.selectedElementId === elementId) {
            this.selectedElementId = null;
        }
        this.markAsModified();
        this.updateTemplate();
    }
},
                
duplicateElement( elementId ) {
    this.saveState('Duplicate element');
    const element = this.findElementById(elementId);
    if ( !element ) return;
    
    const duplicate = Utils.deepClone(element);
    duplicate.id = Utils.generateId();
    
    // Preserve the original element type and properties
    if (duplicate.label) {
        duplicate.label = duplicate.label + ' Copy';
    } else {
        duplicate.label = (duplicate.type || 'Element') + ' Copy';
    }
    
    // Ensure nested elements get new IDs but preserve their structure
    this.updateNestedIds(duplicate);
    
    // Find the parent container and add the duplicate
    const parentContainer = Utils.findElementParent(this.currentTemplate.elements, elementId);
    if (parentContainer) {
        parentContainer.push(duplicate);
    } else {
        // Element is at root level
        this.currentTemplate.elements.push(duplicate);
    }
    
    this.markAsModified();
    this.updateTemplate();
},
                
updateNestedIds( element ) {
    if ( element.elements ) {
        element.elements.forEach(child => {
            child.id = Utils.generateId();
            this.updateNestedIds(child);
        });
    }
},

updateTemplate() {
    this.markAsModified();
    this.currentTemplate = { ...this.currentTemplate };
    this.$nextTick(() => { 
        window.editorInstance = this;
        this.setupDropZoneListeners();
    });
},

setupDropZoneListeners() {
    // Remove existing listeners
    document.querySelectorAll('.drop-zone').forEach(zone => {
        zone.replaceWith(zone.cloneNode(true));
    });
    
    // Add unified drop zone listeners
    document.querySelectorAll('.drop-zone').forEach(zone => {
        const containerId = zone.getAttribute('data-container-id');
        const subIndex = zone.getAttribute('data-sub-index');
        
        if (!containerId) return;
        
        zone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.handleContainerDragOver(e, containerId, subIndex ? parseInt(subIndex) : null);
        });
        
        zone.addEventListener('dragleave', (e) => {
            if (!zone.contains(e.relatedTarget)) {
                this.handleContainerDragLeave(e);
            }
        });
        
        zone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.handleContainerDrop(e, containerId, subIndex ? parseInt(subIndex) : null);
        });
    });
    
    this.updateAllPlaceholders();
},
                
async saveTemplate() {
    if (!this.currentTemplate) {
        Utils.showNotification('No template to save', 'error');
        return;
    }
    
    if (!this.currentTemplate.title) {
        Utils.showNotification('Template must have a title', 'error');
        return;
    }

    try {
        Utils.showNotification('Saving template...', 'info');
        
        // Save template - DataManager will handle ID generation/updating
        const templateId = await DataManager.saveTemplate(this.currentTemplate);
        
        // Update local references to use the returned ID
        this.availableTemplates[templateId] = Utils.deepClone(this.currentTemplate);
        this.selectedTemplateId = templateId;
        this.isModified = false;
        
        Utils.showNotification(`Template saved successfully`, 'success');
    } catch (error) {
        Utils.showNotification(`Failed to save template: ${error.message}`, 'error');
        console.error('Save template error:', error);
    }
},
                
                exportTemplate() {
                    if (!this.currentTemplate) {
                        Utils.showNotification('No template to export', 'error');
                        return;
                    }
                    DataManager.exportTemplate(this.selectedTemplateId);
                    Utils.showNotification('Template exported', 'success');
                },
                
                previewTemplate() {
                    if (!this.currentTemplate) {
                        Utils.showNotification('No template to preview', 'error');
                        return;
                    }
                    const templateJson = JSON.stringify(this.currentTemplate, null, 2);
                    const previewWindow = window.open('', '_blank');
                    previewWindow.document.write(`<html><head><title>Template Preview</title><style>body{font-family:Arial,sans-serif;padding:2rem}pre{background:#f5f5f5;padding:1rem;border-radius:4px;overflow:auto}</style></head><body><h1>Template Preview: ${this.currentTemplate.title}</h1><h2>JSON Output:</h2><pre>${templateJson}</pre></body></html>`);
                },

		updateImageDimension( dimension, value ) {
		    if (!this.selectedElementId) return;
		    const element = this.findElementById(this.selectedElementId);
		    if (!element) return;
    
		    const oldWidth = element.width || 150;
		    const oldHeight = element.height || 150;
    
		    element[dimension] = value;
    
		    if (element.maintainAspectRatio === true) {
		        const aspectRatio = oldWidth / oldHeight;
		        if (dimension === 'width') {
		            element.height = Math.round(value / aspectRatio);
		        } else if (dimension === 'height') {
		            element.width = Math.round(value * aspectRatio);
		        }
		    }
		    this.markAsModified();
		    this.currentTemplate = { ...this.currentTemplate };
		},

// Initialize Undo/Redo System
initUndoRedo() {
    this.undoManager = new Utils.UndoRedoManager(50);
    
    // Set up state getter
    this.undoManager.setCurrentStateGetter(() => this.currentTemplate);
    
    // Set up state change callback
    this.undoManager.onStateChange = () => {
        this.canUndo = this.undoManager.canUndo();
        this.canRedo = this.undoManager.canRedo();
    };
},

saveState(description = 'Template change') {
    if (this.undoManager && !this.undoManager.isUndoRedoOperation) {
        this.undoManager.saveState(this.currentTemplate, description);
    }
},

setupKeyboardShortcuts() {
    this.keyboardManager = new Utils.KeyboardShortcuts();
    this.keyboardManager.startListening();
    
    // Create action provider with all available actions
    const actionProvider = {
        actions: {
            // File operations
            'save': () => { if (this.isModified)  this.saveTemplate(); },
            'import': this.importTemplate.bind(this),
            'export': () => { if (this.selectedTemplateId && this.selectedTemplateId !== '_new')  this.exportTemplate(); },
            'new': this.createNewTemplate.bind(this),
            'undo': this.undo.bind(this),
            'redo': this.redo.bind(this),
            'toggle-left-pane': this.toggleLeftPane.bind(this),
            'toggle-right-pane': this.toggleRightPane.bind(this),
            'preview': this.previewTemplate.bind(this)
        },
        getAction: (actionId) => actionProvider.actions[actionId],
        getAvailableActions: () => Object.keys(actionProvider.actions)
    };
    
    this.$nextTick(() => {
        Utils.ActionRegistry.registerProvider('template', actionProvider, {
            name: 'Template Editor',
            description: 'Actions available in the template editor',
            icon: 'üìù'
        });
        
        Utils.applyShortcutsFromRegistry(this.keyboardManager, 'template', actionProvider);
    });
},

undo() {
    if (!this.undoManager || !this.undoManager.canUndo()) {
        Utils.showNotification('Nothing to undo', 'info');
        return;
    }
    
    const previousState = this.undoManager.undo();
    if (previousState) {
        Object.assign(this.currentTemplate, Utils.deepClone(previousState));
        this.selectedElementId = null; // Clear selection since element might not exist
        this.isModified = true;
        
        // Force re-render
        this.$nextTick(() => {
            this.currentTemplate = { ...this.currentTemplate };
            this.undoManager.finishUndoRedo();
        });
    }
},

redo() {
    if (!this.undoManager || !this.undoManager.canRedo()) {
        Utils.showNotification('Nothing to redo', 'info');
        return;
    }
    
    const nextState = this.undoManager.redo();
    if (nextState) {
        Object.assign(this.currentTemplate, Utils.deepClone(nextState));
        this.selectedElementId = null; // Clear selection since element might not exist
        this.isModified = true;
        
        // Force re-render
        this.$nextTick(() => {
            this.currentTemplate = { ...this.currentTemplate };
            this.undoManager.finishUndoRedo();
        });
    }
},

importTemplate() {
    if (!this.selectedSchemaId) {
        Utils.showNotification('Please select a system first', 'error');
        return;
    }

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (event) => {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    this.handleTemplateImport(importedData);
                } catch (error) {
                    Utils.showNotification('Invalid JSON file. Please check the file format.', 'error');
                    console.error('Import error:', error);
                }
            };
            reader.onerror = () => {
                Utils.showNotification('Error reading file', 'error');
            };
            reader.readAsText(file);
        }
    };
    input.click();
},

handleTemplateImport(importedData) {
    // Validate imported template data
    if (!importedData || typeof importedData !== 'object') {
        Utils.showNotification('Invalid template data format', 'error');
        return;
    }
    
    // Check if it's a complete template object or validate required fields
    if (!importedData.title) {
        Utils.showNotification('Template must have a title', 'error');
        return;
    }
    
    if (!importedData.elements || !Array.isArray(importedData.elements)) {
        Utils.showNotification('Template must have valid elements array', 'error');
        return;
    }
    
    // Check if schema matches or is compatible
    const currentSchema = DataManager.getSchema(this.selectedSchemaId);
    if (importedData.schema && importedData.schema !== currentSchema.index) {
        const confirmMessage = `This template was designed for "${importedData.schema}" but you have "${currentSchema.index}" selected. Import anyway?`;
        if (!confirm(confirmMessage)) {
            return;
        }
    }
    
    // Save current state for undo
    this.saveState('Template import');
    
    // Prepare the template data
    const templateData = {
        title: importedData.title + (importedData.title.includes('(Imported)') ? '' : ' (Imported)'),
        schema: currentSchema.index, // Use currently selected schema
        type: importedData.type || 'VerticalLayout',
        elements: importedData.elements || []
    };
    
    // Ensure all elements have IDs
    this.ensureElementIds(templateData.elements);
    
    // Import the template
    this.currentTemplate = Utils.deepClone(templateData);
    this.selectedTemplateId = '_new'; // Treat as new template
    this.selectedElementId = null;
    this.isModified = true;
    this.activeTemplateTab = 0;
    
    // Update available fields for the current schema
    this.availableFields = DataManager.generateFieldPaths(this.selectedSchemaId);
    
    this.$nextTick(() => {
        this.currentTemplate = { ...this.currentTemplate };
    });
    
    Utils.showNotification(`Template "${templateData.title}" imported successfully`, 'success');
},
                
		renderElement( element, index ) {
		    return Utils.ElementRenderer.renderElement(element, {
		        isPreview: true,
		        selectedElementId: this.selectedElementId,
		        getValue: () => '',
		        instanceRef: this
		    });
		}

            };
        }

        document.addEventListener('alpine:init', () => { 
            Alpine.data('templateEditor', templateEditor); 
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const appElement = document.querySelector('[x-data="templateEditor()"]');
                if (appElement && appElement._x_dataStack) {
                    window.editorInstance = appElement._x_dataStack[0];
                }
            }, 100);
        });
    </script>
</body>
</html>